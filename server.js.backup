const express = require('express');
const session = require('express-session');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const multer = require('multer');
const axios = require('axios');
const { TwitterApi } = require('twitter-api-v2');
const OpenAI = require('openai');
const cron = require('node-cron');
const moment = require('moment');
require('dotenv').config();
const cheerio = require('cheerio');

// Removed OpenRouter - now using Google Gemini for AI features

const app = express();
const PORT = process.env.PORT || 3000;

// Ensure uploads directory exists
const uploadDir = path.join(__dirname, 'uploads');
if (!fsSync.existsSync(uploadDir)) {
  fsSync.mkdirSync(uploadDir, { recursive: true });
}

// Multer configuration for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'image-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit per file
  fileFilter: function (req, file, cb) {
    const allowedTypes = /jpeg|jpg|png|gif|webp/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Ch??ch?p nh?n file ?nh (JPEG, PNG, GIF, WebP)'));
    }
  }
});

// Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(session({
  secret: process.env.SESSION_SECRET || 'twitter-secret-key-2024',
  resave: false,
  saveUninitialized: true,
  cookie: { secure: false }
}));

// Set view engine with UTF-8 support
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Ensure UTF-8 encoding for all responses
app.use((req, res, next) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  next();
});

// Static files
app.use(express.static('public'));

// Config file path
const CONFIG_FILE = path.join(__dirname, 'twitter-config.json');

// OpenRouter AI client
const openai = new OpenAI({
  baseURL: "https://openrouter.ai/api/v1",
  apiKey: process.env.OPENROUTER_API_KEY,
});

// OpenRouter API key constant
const OPENROUTER_KEY = process.env.OPENROUTER_API_KEY;

// Scheduled tweets storage (server-side scheduling since Twitter API v2 doesn't support native scheduling)
let scheduledTweets = [];
let scheduledJobs = new Map();

// Helper function to determine MIME type from response or URL
function getMimeTypeFromResponse(response, url) {
  let mimeType = 'image/jpeg'; // default
  const contentType = response.headers['content-type'];
  
  if (contentType && contentType.startsWith('image/')) {
    mimeType = contentType;
    console.log(`?? MIME type from Content-Type header: ${mimeType}`);
  } else {
    // Guess from URL extension
    const urlLower = url.toLowerCase();
    if (urlLower.includes('.png')) mimeType = 'image/png';
    else if (urlLower.includes('.gif')) mimeType = 'image/gif';
    else if (urlLower.includes('.webp')) mimeType = 'image/webp';
    else if (urlLower.includes('.bmp')) mimeType = 'image/bmp';
    else if (urlLower.includes('.jpg') || urlLower.includes('.jpeg')) mimeType = 'image/jpeg';
    
    console.log(`?? MIME type from URL extension: ${mimeType} (URL: ${url})`);
  }
  
  // Ensure we have a valid MIME type
  if (!mimeType || !mimeType.startsWith('image/')) {
    mimeType = 'image/jpeg';
    console.log(`?? Fallback to default MIME type: ${mimeType}`);
  }
  
  return mimeType;
}

// Helper function to upload image buffer to Twitter (try both methods)
async function uploadImageToTwitter(client, imageBuffer, mimeType, context = '') {
  // Validate buffer
  if (!Buffer.isBuffer(imageBuffer) || imageBuffer.length === 0) {
    throw new Error('Invalid image buffer');
  }
  
  console.log(`?? Uploading image ${context}: ${mimeType}, ${imageBuffer.length} bytes`);
  
  // Method 1: Try direct buffer upload with correct Twitter API format
  try {
    console.log(`?? Buffer info ${context}: isBuffer=${Buffer.isBuffer(imageBuffer)}, length=${imageBuffer.length}, mimeType=${mimeType}`);
    
    // Twitter API v1 expects the media parameter to be a Buffer with mimeType option
    const mediaId = await client.v1.uploadMedia(imageBuffer, { mimeType });
    console.log(`???? upload ?nh tr?c ti?p (buffer) ${context}, Media ID:`, mediaId);
    return mediaId;
  } catch (bufferError) {
    console.error(`??Buffer upload failed ${context}:`, bufferError.message);
    console.error(`??Buffer error details:`, {
      message: bufferError.message,
      code: bufferError.code,
      status: bufferError.status
    });
  }
  
  // Method 2: Fallback to temporary file method
  let tempFilePath = null;
  try {
    // Determine file extension from MIME type
    let extension = '.jpg';
    if (mimeType.includes('png')) extension = '.png';
    else if (mimeType.includes('gif')) extension = '.gif';
    else if (mimeType.includes('webp')) extension = '.webp';
    
    // Create temporary file
    const tempFileName = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 11)}${extension}`;
    tempFilePath = path.join(uploadDir, tempFileName);
    
    // Write buffer to temporary file
    await fs.writeFile(tempFilePath, imageBuffer);
    
    // Upload file to Twitter
    const mediaId = await client.v1.uploadMedia(tempFilePath);
    console.log(`???? upload ?nh qua file ${context}, Media ID:`, mediaId);
    
    return mediaId;
  } catch (fileError) {
    console.error(`??C??2 ph??ng ph��p upload ??u th?t b?i ${context}:`, fileError.message);
    throw new Error(`Upload failed ${context}: ${fileError.message}`);
  } finally {
    // Clean up temporary file
    if (tempFilePath) {
      try {
        await fs.unlink(tempFilePath);
        console.log(`?????? x��a file t?m: ${path.basename(tempFilePath)}`);
      } catch (cleanupError) {
        console.warn(`?? Kh?ng th??x��a file t?m: ${cleanupError.message}`);
      }
    }
  }
}

// Load Twitter config
async function loadConfig() {
  try {
    const data = await fs.readFile(CONFIG_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return {
      appKey: '',
      appSecret: '',
      accessToken: '',
      accessSecret: ''
    };
  }
}

// Save Twitter config
async function saveConfig(config) {
  await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
}

// Check if Twitter keys are configured
function hasTwitterKeys(config) {
  return !!(config.appKey && config.appSecret && config.accessToken && config.accessSecret);
}

// Create Twitter client
function createTwitterClient(config) {
  return new TwitterApi({
    appKey: config.appKey,
    appSecret: config.appSecret,
    accessToken: config.accessToken,
    accessSecret: config.accessSecret,
  });
}

// Parse and format AI content to proper display format
function parseAndFormatAIContent(rawContent) {
  try {
    // Remove any markdown formatting or extra brackets
    let content = rawContent.replace(/\[|\]/g, '').trim();
    
    // Split content into lines and filter out empty lines
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    
    if (lines.length === 0) {
      throw new Error('Empty AI content');
    }
    
    let mainContent = '';
    let linkContent = '';
    let hashtags = '';
    
    // Parse different sections
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines
      if (!line) continue;
      
      // Check if line contains hashtags (starts with # or contains multiple #)
      if (line.includes('#') && (line.startsWith('#') || (line.match(/#/g) || []).length >= 2)) {
        hashtags = line;
      }
      // Check if line contains 6868.run
      else if (line.includes('6868.run')) {
        linkContent = line;
      }
      // Otherwise it's main content
      else if (!mainContent) {
        mainContent = line;
      }
    }
    
    // Build final formatted content
    let finalContent = '';
    
    // Add main content
    if (mainContent) {
      finalContent += mainContent;
    }
    
    // Add link content
    if (linkContent) {
      finalContent += '\n\n' + linkContent;
    } else {
      // Fallback link if not generated
      finalContent += '\n\n?? ���ָ��ྫ������ 6868.run';
    }
    
    // Add hashtags
    if (hashtags) {
      finalContent += '\n\n' + hashtags;
    } else {
      // Fallback hashtags if not generated
      finalContent += '\n\n#��Ʒ #�Ƽ� #���� #�ղ� #����';
    }
    
    console.log('?? �������:', {
      mainContent,
      linkContent,
      hashtags,
      finalContent: finalContent.substring(0, 100) + '...'
    });
    
    return finalContent;
    
  } catch (error) {
    console.error('??����AI����ʧ��:', error);
    // Return raw content if parsing fails
    return rawContent;
  }
}

// Generate Chinese content based on title using AI
async function generateChineseContentFromTitle(title) {
  try {
    if (!process.env.OPENROUTER_API_KEY || process.env.OPENROUTER_API_KEY === 'your_openrouter_api_key_here') {
      throw new Error('Not configured h��nh OpenRouter API key');
    }

    const prompt = `���ݱ���"${title}"��������Twitter�ƹ����ݣ�Ҫ��

1. ���ƹ��İ���20-30�֣���Χ�Ʊ������ݣ���1��emoji���������
2. ����������10-15�֣���������������6868.run
3. ���ű�ǩ��3���������hashtag

���ϸ����¸�ʽ���أ�ÿ��һ�����ݣ�������������200�֣���
?? ����ƹ��İ�

?? �������� 6868.run

#��ǩ1 #��ǩ2 #��ǩ3`;

    const completion = await openai.chat.completions.create({
      model: "anthropic/claude-3-haiku",
      messages: [
        {
          role: "system",
          content: "����һλרҵ�������罻ý��Ӫ��ר�ң��ó�����Twitter�ƹ����ݡ�����Ҫ���������ƹ��İ���������������������hashtag���������ݡ�"
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 100,
      temperature: 0.7
    });

    const rawContent = completion.choices[0].message.content.trim();
    console.log('??AI����ԭʼ����:', rawContent);
    
    // Parse and format the AI content properly
    const formattedContent = parseAndFormatAIContent(rawContent);
    console.log('??AI��ʽ��������:', formattedContent);
    
    return formattedContent;
  } catch (error) {
    console.error('? L?i t?o Content required AI:', error);
    
    // Fallback to simple template if AI fails
    return getRandomChineseContent();
  }
}

// Schedule tweet function using server-side cron job (Twitter API v2 doesn't support native scheduling)
function scheduleTweet(tweetData, scheduledTime) {
  const tweetId = Date.now() + Math.random();
  
  // Parse scheduled time
  const scheduleDate = new Date(scheduledTime);
  const now = new Date();
  
  // Check if time is in the future
  if (scheduleDate <= now) {
    console.error('??Th?i gian l?p l?ch ph?i trong t??ng lai:', scheduleDate, 'hi?n t?i:', now);
    throw new Error('Th?i gian l?p l?ch ph?i trong t??ng lai');
  }
  
  // Create cron format: second minute hour day month dayOfWeek
  const cronTime = `${scheduleDate.getSeconds()} ${scheduleDate.getMinutes()} ${scheduleDate.getHours()} ${scheduleDate.getDate()} ${scheduleDate.getMonth() + 1} *`;
  
  console.log('?? L?p l?ch tweet (server-side):', {
    id: tweetId,
    scheduledTime: scheduleDate.toLocaleString('vi-VN'),
    cronFormat: cronTime,
    content: tweetData.text.substring(0, 50) + '...',
    timeUntil: Math.round((scheduleDate.getTime() - now.getTime()) / 1000 / 60) + ' ph��t'
  });

  // T?o cron job
  const job = cron.schedule(cronTime, async () => {
    try {
      console.log('?? ?ang ??ng tweet theo l?ch:', tweetId, 'v��o l��c:', new Date().toLocaleString('vi-VN'));
      await postScheduledTweet(tweetData);
      
      // X��a job sau khi ho��n th��nh
      scheduledJobs.delete(tweetId);
      scheduledTweets = scheduledTweets.filter(t => t.id !== tweetId);
      console.log('???? ho��n th��nh v�� x��a job:', tweetId);
      
    } catch (error) {
      console.error('??L?i ??ng tweet theo l?ch:', tweetId, error);
    }
  }, {
    scheduled: true, // Start immediately
    timezone: 'Asia/Ho_Chi_Minh' // Set timezone
  });

  // L?u th?ng tin
  const scheduledTweet = {
    id: tweetId,
    ...tweetData,
    scheduledTime: scheduledTime,
    status: 'scheduled',
    createdAt: new Date(),
    cronFormat: cronTime
  };

  scheduledTweets.push(scheduledTweet);
  scheduledJobs.set(tweetId, job);
  
  console.log('???? t?o cron job th��nh c?ng:', tweetId);
  
  return tweetId;
}

// Post scheduled tweet
async function postScheduledTweet(tweetData) {
  const config = await loadConfig();
  if (!hasTwitterKeys(config)) {
    throw new Error('Not configured h��nh kh��a Twitter');
  }

  const client = createTwitterClient(config);
  let mediaIds = [];
  
  // Handle images if any - upload directly without saving
  if (tweetData.imageUrls && tweetData.imageUrls.length > 0) {
    for (const url of tweetData.imageUrls.slice(0, 2)) {
      try {
        console.log('???ang t?i ?nh t??URL (scheduled):', url);
        const response = await axios.get(url, {
          responseType: 'arraybuffer',
          timeout: 15000,
          headers: { 'User-Agent': 'Mozilla/5.0' },
          maxContentLength: 5 * 1024 * 1024 // 5MB limit
        });

        // Validate response
        if (!response.data || response.data.length === 0) {
          throw new Error('Empty response data');
        }

        console.log(`?? ?? t?i ?nh: ${response.data.length} bytes, Content-Type: ${response.headers['content-type']}`);

        // Upload to Twitter
        const mimeType = getMimeTypeFromResponse(response, url);
        const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(scheduled)');
        mediaIds.push(mediaId);
        
      } catch (error) {
        console.error('??L?i x??ly ?nh trong tweet l?p l?ch:', error);
        // Continue with other images if one fails
      }
    }
  }

  // Post tweet
  const tweetOptions = { text: tweetData.text };
  if (mediaIds.length > 0) {
    tweetOptions.media = { media_ids: mediaIds };
  }
  
  const tweet = await client.v2.tweet(tweetOptions);
  console.log('???? ??ng tweet theo l?ch th��nh c?ng! Tweet ID:', tweet.data.id);
  
  return tweet;
}



// Fetch page data with titles and images from API
async function fetchPageDataFromAPI(apiUrl) {
  try {
    console.log('?? ?ang l?y d??li?u t??API:', apiUrl);
    const response = await axios.get(apiUrl, {
      timeout: 10000,
      headers: { 'User-Agent': 'Mozilla/5.0' }
    });
    
    console.log('?? C?u tr��c API response:', Object.keys(response.data));
    
    let articles = [];
    
    // Ki?m tra c?u tr��c API c??th??cho beiyong.slapibf.com
    if (response.data.list && Array.isArray(response.data.list)) {
      console.log('??T��m th?y field "list" v?i', response.data.list.length, 'items');
      articles = response.data.list.map(item => {
        const title = item.art_name || item.title || item.name || item.headline || 'No title';
        
        // L?y h��nh ?nh t??nhi?u ngu?n
        let images = [];
        
        // 1. T??art_pic
        if (item.art_pic) {
          if (typeof item.art_pic === 'string') {
            // N?u l�� string, c�� th??ch?a nhi?u URL phan c��ch b?i d?u ph?y, |, ho?c xu?ng d��ng
            const imageUrls = item.art_pic.split(/[,|\n]/).map(url => url.trim()).filter(url => url && url.startsWith('http'));
            images = images.concat(imageUrls);
          } else if (Array.isArray(item.art_pic)) {
            images = images.concat(item.art_pic.filter(url => url && url.startsWith('http')));
          }
        }
        
        // 2. T??art_content (t��m URL ?nh trong Content required)
        if (item.art_content) {
          const imgMatches = item.art_content.match(/https?:\/\/[^\s"'<>]+\.(jpg|jpeg|png|gif|webp)/gi) || [];
          images = images.concat(imgMatches);
        }
        
        // 3. T??c��c field kh��c c�� th??ch?a ?nh
        ['art_thumb', 'art_logo', 'art_cover', 'thumb', 'cover', 'image'].forEach(field => {
          if (item[field] && typeof item[field] === 'string' && item[field].startsWith('http')) {
            images.push(item[field]);
          }
        });
        
        // Lo?i b??duplicate v�� l?y t?i ?a 2 ?nh
        images = [...new Set(images)].slice(0, 2);
        
        console.log(`?? B��i "${title.substring(0, 30)}..." c�� ${images.length} ?nh:`, images.slice(0, 2));
        
        return {
          title: title.replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').trim(),
          images: images,
          originalData: item
        };
      });
    } else {
      throw new Error('API kh?ng tr??v??c?u tr��c d??li?u mong ??i');
    }
    
    console.log('?? ?? l?y ???c', articles.length, 'b��i vi?t');
    console.log('?? B��i vi?t ??u ti��n:', articles[0]?.title, '- S???nh:', articles[0]?.images?.length || 0);
    
    return articles;
  } catch (error) {
    console.error('??L?i l?y d??li?u t??API:', error);
    throw new Error('Kh?ng th??l?y d??li?u t??API: ' + error.message);
  }
}

// Fetch first article from an external API URL and extract title + image URLs
async function fetchFirstArticleFromApi(apiUrl) {
  const res = await axios.get(apiUrl, { timeout: 15000 });
  const body = res.data;

  // Try to find an object that contains art_name and art_content
  function findArticle(obj) {
    if (!obj || typeof obj !== 'object') return null;
    if (obj.art_name && obj.art_content) return obj;
    for (const k of Object.keys(obj)) {
      const v = obj[k];
      if (Array.isArray(v)) {
        for (const item of v) {
          const found = findArticle(item);
          if (found) return found;
        }
      } else if (typeof v === 'object') {
        const found = findArticle(v);
        if (found) return found;
      }
    }
    return null;
  }

  const article = findArticle(body);
  if (!article) throw new Error('Kh?ng t��m th?y b��i vi?t (art_name / art_content) trong ph?n h?i API');

  const artName = article.art_name;
  const artContent = article.art_content || '';

  // Parse HTML and extract image src attributes
  const $ = cheerio.load(artContent);
  const imgs = [];
  $('img').each((i, el) => {
    const src = $(el).attr('src');
    if (src) imgs.push(src);
  });

  // Return title and up to 4 image URLs
  return {
    art_name: artName,
    imageUrls: imgs.slice(0, 2)
  };
}

// Read content from DOCX files
async function getContentFromDocx() {
  try {
    const docxDir = path.join(__dirname, 'docx');
    const files = await fs.readdir(docxDir);
    const docxFiles = files.filter(f => f.endsWith('.docx'));
    
    if (docxFiles.length === 0) {
      throw new Error('Kh?ng t��m th?y file DOCX n��o');
    }

    // For now, we'll return a placeholder
    // You can integrate mammoth.js or docx library to extract text
    const fileName = docxFiles[0];
    return {
      fileName,
      content: `Content required t????ng t??file ${fileName}. ?ay l�� b��i vi?t ???c t?o t????ng t??h??th?ng.`
    };
  } catch (error) {
    throw new Error(`L?i ??c file DOCX: ${error.message}`);
  }
}





// Routes
app.get('/', (req, res) => {
  res.send(`
    <!DOCTYPE html>
    <html lang="vi">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Twitter Auto Post System</title>
      <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
        }
        .container {
          background: white;
          padding: 40px;
          border-radius: 20px;
          box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          text-align: center;
          max-width: 500px;
        }
        h1 { color: #1da1f2; margin-bottom: 20px; font-size: 32px; }
        p { color: #666; margin-bottom: 30px; line-height: 1.6; }
        .links { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; }
        a {
          padding: 14px 28px;
          background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);
          color: white;
          text-decoration: none;
          border-radius: 10px;
          font-weight: 600;
          transition: all 0.3s;
          box-shadow: 0 4px 12px rgba(29, 161, 242, 0.3);
        }
        a:hover {
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(29, 161, 242, 0.4);
        }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>?? Twitter Auto Post</h1>
        <p>H??th?ng t????ng ??ng b��i l��n Twitter t??file DOCX</p>
        <div class="links">
          <a href="/twitter">?? Qu?n ly Twitter</a>
          <a href="/docx">?? Xem DOCX</a>
        </div>
      </div>
    </body>
    </html>
  `);
});

app.get('/twitter', async (req, res) => {
  const cfg = await loadConfig();
  res.render('twitter', {
    title: 'Qu?n ly Twitter',
    cfg,
    hasKeys: hasTwitterKeys(cfg)
  });
});

app.get('/docx', async (req, res) => {
  try {
    const docxDir = path.join(__dirname, 'docx');
    await fs.mkdir(docxDir, { recursive: true });
    const files = await fs.readdir(docxDir);
    const docxFiles = files.filter(f => f.endsWith('.docx'));
    
    res.send(`
      <!DOCTYPE html>
      <html lang="vi">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Danh s��ch DOCX</title>
        <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
          }
          .container { max-width: 800px; margin: 0 auto; }
          .header {
            background: white;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
          }
          h1 { color: #1da1f2; margin-bottom: 12px; }
          .file-list {
            background: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
          }
          .file-item {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
          }
          .file-item:last-child { border-bottom: none; }
          .file-name { font-weight: 500; color: #333; }
          .btn {
            padding: 8px 16px;
            background: #1da1f2;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>?? Danh s��ch file DOCX</h1>
            <a href="/" style="color: #666; text-decoration: none;">??Quay l?i</a>
          </div>
          <div class="file-list">
            ${docxFiles.length ? docxFiles.map(f => `
              <div class="file-item">
                <span class="file-name">?? ${f}</span>
                <a href="#" class="btn">Xem Content required</a>
              </div>
            `).join('') : '<p style="text-align: center; color: #666;">Ch?a c�� file DOCX n��o trong th? m?c /docx</p>'}
          </div>
        </div>
      </body>
      </html>
    `);
  } catch (error) {
    res.status(500).send('L?i: ' + error.message);
  }
});

// API: Save Twitter keys
app.post('/api/twitter/keys', async (req, res) => {
  try {
    const { appKey, appSecret, accessToken, accessSecret } = req.body;
    await saveConfig({ appKey, appSecret, accessToken, accessSecret });
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Removed AI content generation endpoint

// API: Fetch page data with titles and images
app.post('/api/fetch-page-data', async (req, res) => {
  try {
    const { apiUrl } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const articles = await fetchPageDataFromAPI(apiUrl.trim());
    
    res.json({ 
      success: true, 
      articles: articles,
      message: `?? l?y ${articles.length} b��i vi?t t??API`
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Generate Chinese content from title
app.post('/api/ai/generate-content', async (req, res) => {
  try {
    const { title } = req.body;
    
    if (!title || title.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide title' 
      });
    }

    const content = await generateChineseContentFromTitle(title.trim());
    
    res.json({ 
      success: true, 
      content: content,
      message: '?? t?o Content required AI th��nh c?ng'
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Bulk process 20 articles - fetch, generate AI content, and schedule posts
app.post('/api/bulk-process', async (req, res) => {
  try {
    const { apiUrl, page } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    // Step 1: Fetch 20 articles from API
    console.log('?? B??c 1: L?y 20 b��i t??API...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Kh?ng l?y ???c b��i vi?t n��o t??API' 
      });
    }

    // Take only first 20 articles
    const selectedArticles = articles.slice(0, 20);
    console.log(`???? l?y ${selectedArticles.length} b��i vi?t`);

    // Step 2: Generate AI content for each article
    console.log('?? B??c 2: T?o Content required AI cho t?ng b��i...');
    const processedArticles = [];
    
    for (let i = 0; i < selectedArticles.length; i++) {
      const article = selectedArticles[i];
      console.log(`?? X??ly b��i ${i + 1}/${selectedArticles.length}: ${article.title.substring(0, 30)}...`);
      
      try {
        // Generate AI content
        const aiContent = await generateChineseContentFromTitle(article.title);
        
        // Prepare tweet data
        const tweetData = {
          text: `${article.title}\n\n${aiContent}`,
          imageUrls: article.images.slice(0, 2) // Take first 2 images
        };
        
        processedArticles.push({
          ...article,
          aiContent: aiContent,
          tweetData: tweetData
        });
        
        console.log(`??Ho��n th��nh b��i ${i + 1}`);
        
        // Small delay to avoid rate limiting
        if (i < selectedArticles.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
      } catch (error) {
        console.error(`??L?i x??ly b��i ${i + 1}:`, error);
        // Use fallback content if AI fails
        const fallbackContent = getRandomChineseContent();
        processedArticles.push({
          ...article,
          aiContent: fallbackContent,
          tweetData: {
            text: `${article.title}\n\n${fallbackContent}`,
            imageUrls: article.images.slice(0, 2)
          }
        });
      }
    }

    // Step 3: Schedule posts - 20 b��i chia 5 ng��y, m?i ng��y 4 b��i
    console.log('?? B??c 3: L?p l?ch ??ng b��i...');
    const scheduleResults = await scheduleArticlesBulk(processedArticles);
    
    res.json({ 
      success: true, 
      message: `?? x??ly v�� l?p l?ch ${processedArticles.length} b��i th��nh c?ng!`,
      articlesProcessed: processedArticles.length,
      scheduledTweets: scheduleResults.length,
      scheduleDetails: scheduleResults
    });

  } catch (error) {
    console.error('??L?i x??ly bulk:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Function to get random Chinese content (fallback)
function getRandomChineseContent() {
  const templates = [
    "?? �����������ݣ���ѡ��������Դ\n\n?? �������� 6868.run\n\n#���� #��ѡ #������",
    "? ������ذ汾�����廭��������¼\n\n?? ���鶥��Ʒ�� 6868.run\n\n#���� #��� #����",
    "?? VIPר����Դ����Ա������Ȩ����\n\n?? ̽�����ྪϲ 6868.run\n\n#VIP #ר�� #��Ȩ",
    "?? �����Ƽ�ϵ�У�����ǿ���Ƽ�\n\n?? ���ܾ������� 6868.run\n\n#�Ƽ� #�ڱ� #����",
    "?? ��Ʒ�ղرر�����������Ʒ��\n\n?? ���ָ��ྫƷ 6868.run\n\n#��Ʒ #���� #����"
  ];
  return templates[Math.floor(Math.random() * templates.length)];
}

// Function to schedule articles in bulk (5 days, 4 posts per day)
async function scheduleArticlesBulk(articles) {
  const scheduleResults = [];
  const postsPerDay = 4;
  const timeSlots = ['08:00', '12:00', '17:00', '21:00']; // S��ng, tr?a, chi?u, t?i
  
  // Start from tomorrow
  const startDate = new Date();
  startDate.setDate(startDate.getDate() + 1);
  startDate.setHours(0, 0, 0, 0);
  
  for (let i = 0; i < articles.length; i++) {
    const article = articles[i];
    const dayOffset = Math.floor(i / postsPerDay);
    const timeSlotIndex = i % postsPerDay;
    
    // Calculate schedule time
    const scheduleDate = new Date(startDate);
    scheduleDate.setDate(scheduleDate.getDate() + dayOffset);
    
    const [hours, minutes] = timeSlots[timeSlotIndex].split(':').map(Number);
    scheduleDate.setHours(hours, minutes, 0, 0);
    
    try {
      // Schedule the tweet
      const tweetId = scheduleTweet(article.tweetData, scheduleDate.toISOString());
      
      scheduleResults.push({
        articleIndex: i + 1,
        title: article.title.substring(0, 50) + '...',
        scheduledTime: scheduleDate.toISOString(),
        timeSlot: timeSlots[timeSlotIndex],
        day: dayOffset + 1,
        tweetId: tweetId,
        imageCount: article.tweetData.imageUrls.length
      });
      
      console.log(`?? ?? l?p l?ch b��i ${i + 1}: ${scheduleDate.toLocaleString('vi-VN')} (${timeSlots[timeSlotIndex]})`);
      
    } catch (error) {
      console.error(`??L?i l?p l?ch b��i ${i + 1}:`, error);
      scheduleResults.push({
        articleIndex: i + 1,
        title: article.title.substring(0, 50) + '...',
        error: error.message
      });
    }
  }
  
  return scheduleResults;
}

// API: Schedule tweet using server-side cron job
app.post('/api/twitter/schedule', async (req, res) => {
  try {
    const { text, imageUrls, scheduledTime } = req.body;
    
    if (!text || text.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Content required' 
      });
    }

    if (!scheduledTime) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide ch?n th?i gian ??ng' 
      });
    }

    // Ki?m tra th?i gian ph?i trong t??ng lai
    const scheduleDate = new Date(scheduledTime);
    if (scheduleDate <= new Date()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Th?i gian ??ng ph?i trong t??ng lai' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    // Parse image URLs
    let parsedImageUrls = [];
    if (imageUrls && imageUrls.trim()) {
      parsedImageUrls = imageUrls.split('\n')
        .map(url => url.trim())
        .filter(url => url && url.startsWith('http'))
        .slice(0, 2);
    }

    const tweetData = {
      text: text.trim(),
      imageUrls: parsedImageUrls
    };

    const tweetId = scheduleTweet(tweetData, scheduledTime);
    
    res.json({ 
      success: true, 
      tweetId: tweetId,
      scheduledTime: scheduledTime,
      message: `?? l?p l?ch tweet (server-side) l��c ${moment(scheduledTime).format('DD/MM/YYYY HH:mm')}`
    });
  } catch (error) {
    console.error('??L?i l?p l?ch tweet:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Get scheduled tweets (server-side)
app.get('/api/twitter/scheduled', (req, res) => {
  const tweets = scheduledTweets.map(tweet => ({
    id: tweet.id,
    text: tweet.text.substring(0, 100) + (tweet.text.length > 100 ? '...' : ''),
    scheduledTime: tweet.scheduledTime,
    status: tweet.status,
    createdAt: tweet.createdAt,
    imageCount: tweet.imageUrls ? tweet.imageUrls.length : 0
  }));
  
  res.json({ 
    success: true, 
    tweets: tweets 
  });
});

// API: Cancel scheduled tweet (server-side)
app.delete('/api/twitter/scheduled/:id', (req, res) => {
  try {
    const tweetId = parseInt(req.params.id);
    
    // T��m v�� x��a job
    const job = scheduledJobs.get(tweetId);
    if (job) {
      job.stop();
      job.destroy();
      scheduledJobs.delete(tweetId);
      console.log('?????? h?y job:', tweetId);
    }
    
    // X��a kh?i danh s��ch
    scheduledTweets = scheduledTweets.filter(t => t.id !== tweetId);
    
    res.json({ 
      success: true, 
      message: '?? h?y l?ch ??ng tweet' 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Test image upload
app.post('/api/test/image-upload', async (req, res) => {
  try {
    const { imageUrl } = req.body;
    
    if (!imageUrl) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide imageUrl' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    const client = createTwitterClient(config);
    
    console.log('?? Test upload ?nh t??URL:', imageUrl);
    
    // Download image
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 15000,
      headers: { 'User-Agent': 'Mozilla/5.0' },
      maxContentLength: 5 * 1024 * 1024
    });

    if (!response.data || response.data.length === 0) {
      throw new Error('Empty response data');
    }

    console.log(`?? Test - ?? t?i ?nh: ${response.data.length} bytes, Content-Type: ${response.headers['content-type']}`);

    // Upload to Twitter
    const mimeType = getMimeTypeFromResponse(response, imageUrl);
    const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(test)');
    
    res.json({
      success: true,
      mediaId: mediaId,
      imageSize: response.data.length,
      mimeType: mimeType,
      message: 'Test upload ?nh th��nh c?ng!'
    });

  } catch (error) {
    console.error('??Test upload ?nh th?t b?i:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Debug scheduled jobs
app.get('/api/debug/jobs', (req, res) => {
  const jobsInfo = [];
  
  scheduledJobs.forEach((job, tweetId) => {
    const tweet = scheduledTweets.find(t => t.id === tweetId);
    jobsInfo.push({
      tweetId: tweetId,
      scheduledTime: tweet ? tweet.scheduledTime : 'Unknown',
      cronFormat: tweet ? tweet.cronFormat : 'Unknown',
      status: job.running ? 'Running' : 'Stopped',
      content: tweet ? tweet.text.substring(0, 50) + '...' : 'Unknown'
    });
  });
  
  res.json({
    success: true,
    totalJobs: scheduledJobs.size,
    totalTweets: scheduledTweets.length,
    currentTime: new Date().toLocaleString('vi-VN'),
    jobs: jobsInfo
  });
});

// API: Auto schedule 20 posts with fixed time slots
app.post('/api/auto-schedule-20-fixed', async (req, res) => {
  try {
    const { apiUrl, page } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    // Step 1: Fetch 20 articles from API
    console.log('?? L?y 20 b��i t??API ???l?p l?ch c????nh...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Kh?ng l?y ???c b��i vi?t n��o t??API' 
      });
    }

    // Take only first 20 articles
    const selectedArticles = articles.slice(0, 20);
    console.log(`???? l?y ${selectedArticles.length} b��i vi?t ???l?p l?ch`);

    // Fixed schedule: 5 days, 4 posts per day, starting tomorrow
    const scheduleResults = [];
    const timeSlots = [
      { time: '08:00', name: 'S��ng' },
      { time: '12:00', name: 'Tr?a' }, 
      { time: '17:00', name: 'Chi?u' },
      { time: '21:00', name: 'T?i' }
    ];
    
    // Start from tomorrow 
    const startDate = new Date();
    startDate.setDate(startDate.getDate() + 1);
    startDate.setHours(0, 0, 0, 0);
    
    console.log('?? B?t ??u l?p l?ch t??', startDate.toLocaleDateString('vi-VN'));
    
    for (let i = 0; i < selectedArticles.length; i++) {
      const article = selectedArticles[i];
      console.log(`?? L?p l?ch b��i ${i + 1}/${selectedArticles.length}: ${article.title.substring(0, 30)}...`);
      
      try {
        // Generate AI content
        const aiContent = await generateChineseContentFromTitle(article.title);
        
        // Calculate schedule time - fixed pattern
        const dayOffset = Math.floor(i / 4); // 4 posts per day
        const timeSlotIndex = i % 4; // 0,1,2,3 for morning,noon,evening,night
        
        const scheduleDate = new Date(startDate);
        scheduleDate.setDate(scheduleDate.getDate() + dayOffset);
        
        const [hours, minutes] = timeSlots[timeSlotIndex].time.split(':').map(Number);
        scheduleDate.setHours(hours, minutes, 0, 0);
        
        // Prepare tweet data
        const tweetData = {
          text: `${article.title}\n\n${aiContent}`,
          imageUrls: article.images.slice(0, 2) // Take first 4 images
        };
        
        // Schedule the tweet
        const tweetId = scheduleTweet(tweetData, scheduleDate.toISOString());
        
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          scheduledTime: scheduleDate.toISOString(),
          scheduledTimeVN: scheduleDate.toLocaleString('vi-VN'),
          timeSlot: timeSlots[timeSlotIndex].time,
          timeSlotName: timeSlots[timeSlotIndex].name,
          day: dayOffset + 1,
          tweetId: tweetId,
          imageCount: article.images.length,
          success: true
        });
        
        console.log(`???? l?p l?ch b��i ${i + 1}: ${scheduleDate.toLocaleString('vi-VN')} (${timeSlots[timeSlotIndex].name})`);
        
        // Small delay to avoid overwhelming
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        console.error(`??L?i l?p l?ch b��i ${i + 1}:`, error);
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          error: error.message,
          success: false
        });
      }
    }

    const successCount = scheduleResults.filter(r => r.success).length;
    
    res.json({ 
      success: true, 
      message: `?? t????ng l?p l?ch ${successCount}/${selectedArticles.length} b��i th��nh c?ng!`,
      articlesProcessed: selectedArticles.length,
      scheduledTweets: successCount,
      startDate: startDate.toLocaleDateString('vi-VN'),
      schedulePattern: '4 b��i/ng��y �� 5 ng��y (8h, 12h, 17h, 21h)',
      scheduleDetails: scheduleResults
    });

  } catch (error) {
    console.error('??L?i auto schedule 20 fixed:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Auto schedule 20 posts immediately
app.post('/api/auto-schedule-20', async (req, res) => {
  try {
    const { apiUrl, page } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    // Step 1: Fetch 20 articles from API
    console.log('?? L?y 20 b��i t??API ???l?p l?ch...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Kh?ng l?y ???c b��i vi?t n��o t??API' 
      });
    }

    // Take only first 20 articles
    const selectedArticles = articles.slice(0, 20);
    console.log(`???? l?y ${selectedArticles.length} b��i vi?t ???l?p l?ch`);

    // Step 2: Generate AI content and schedule immediately
    const scheduleResults = [];
    const postsPerDay = 4;
    const timeSlots = ['08:00', '12:00', '17:00', '21:00']; // S��ng, tr?a, chi?u, t?i
    
    // Start from tomorrow
    const startDate = new Date();
    startDate.setDate(startDate.getDate() + 1);
    startDate.setHours(0, 0, 0, 0);
    
    for (let i = 0; i < selectedArticles.length; i++) {
      const article = selectedArticles[i];
      console.log(`?? X??ly v�� l?p l?ch b��i ${i + 1}/${selectedArticles.length}: ${article.title.substring(0, 30)}...`);
      
      try {
        // Generate AI content
        const aiContent = await generateChineseContentFromTitle(article.title);
        
        // Calculate schedule time
        const dayOffset = Math.floor(i / postsPerDay);
        const timeSlotIndex = i % postsPerDay;
        
        const scheduleDate = new Date(startDate);
        scheduleDate.setDate(scheduleDate.getDate() + dayOffset);
        
        const [hours, minutes] = timeSlots[timeSlotIndex].split(':').map(Number);
        scheduleDate.setHours(hours, minutes, 0, 0);
        
        // Prepare tweet data
        const tweetData = {
          text: `${article.title}\n\n${aiContent}`,
          imageUrls: article.images.slice(0, 2) // Take first 4 images
        };
        
        // Schedule the tweet
        const tweetId = scheduleTweet(tweetData, scheduleDate.toISOString());
        
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          scheduledTime: scheduleDate.toISOString(),
          timeSlot: timeSlots[timeSlotIndex],
          day: dayOffset + 1,
          tweetId: tweetId,
          imageCount: article.images.length,
          aiContent: aiContent.substring(0, 50) + '...'
        });
        
        console.log(`???? l?p l?ch b��i ${i + 1}: ${scheduleDate.toLocaleString('vi-VN')} (${timeSlots[timeSlotIndex]})`);
        
        // Small delay to avoid overwhelming
        if (i < selectedArticles.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
      } catch (error) {
        console.error(`??L?i x??ly b��i ${i + 1}:`, error);
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          error: error.message
        });
      }
    }

    const successCount = scheduleResults.filter(r => !r.error).length;
    
    res.json({ 
      success: true, 
      message: `?? t????ng l?p l?ch ${successCount}/${selectedArticles.length} b��i th��nh c?ng!`,
      articlesProcessed: selectedArticles.length,
      scheduledTweets: successCount,
      scheduleDetails: scheduleResults
    });

  } catch (error) {
    console.error('??L?i auto schedule 20:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Removed Chinese tweet generation endpoint

// API: Post tweet (with multiple images or video)
app.post('/api/twitter/post', upload.array('images', 4), async (req, res) => {
  let uploadedFiles = [];
  
  try {
    const { text, imageUrls } = req.body;
    uploadedFiles = req.files || [];
    
    if (!text || text.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Content required' 
      });
    }

    if (text.length > 280) {
      return res.status(400).json({ 
        success: false, 
        error: 'Tweet too long' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured h��nh kh��a Twitter' 
      });
    }

    const client = createTwitterClient(config);
    
    let mediaIds = [];
    const uploadDir = path.join(__dirname, 'uploads');
    if (!fsSync.existsSync(uploadDir)) {
      fsSync.mkdirSync(uploadDir, { recursive: true });
    }

    // Handle images only
    const imagesToUpload = [];
    
    // Add uploaded files
    uploadedFiles.forEach(file => {
      imagesToUpload.push({ type: 'file', path: file.path });
    });

    // Upload images directly from URLs (no file saving)
    if (imageUrls) {
      try {
        const urls = JSON.parse(imageUrls);
        console.log('?? Danh s��ch URL ?nh:', urls);

        for (const url of urls.slice(0, 2)) { // Limit to 2 images
          console.log('???ang t?i ?nh t??URL (main):', url);
          
          try {
            const response = await axios.get(url, {
              responseType: 'arraybuffer',
              timeout: 15000,
              headers: { 
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'image/*,*/*;q=0.8'
              },
              maxContentLength: 5 * 1024 * 1024 // 5MB limit
            });

            // Validate response
            if (!response.data || response.data.length === 0) {
              throw new Error('Empty response data');
            }

            console.log(`?? ?? t?i ?nh (main): ${response.data.length} bytes, Content-Type: ${response.headers['content-type']}`);

            // Upload to Twitter with enhanced error handling
            const mimeType = getMimeTypeFromResponse(response, url);
            console.log(`?? Preparing upload with MIME type: ${mimeType}`);
            
            const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, `(main-${mediaIds.length + 1})`);
            mediaIds.push(mediaId);
            
            console.log(`??Successfully uploaded image ${mediaIds.length}/4 from URL: ${url}`);
            
          } catch (urlError) {
            console.error('??L?i x??ly ?nh t??URL:', url);
            console.error('??Chi ti?t l?i:', urlError.message);
            console.error('??Stack trace:', urlError.stack);
            // Continue with other images if one fails
          }
        }
      } catch (error) {
        console.error('??L?i x??ly danh s��ch URL ?nh:', error);
        // Don't throw error, just continue without images
      }
    }

    // Upload local files to Twitter (if any)
    if (imagesToUpload.length > 0) {
      console.log(`?? T?ng c?ng ${imagesToUpload.length} file local c?n upload`);
      for (const img of imagesToUpload.slice(0, 4 - mediaIds.length)) { // Don't exceed 4 total
        try {
          console.log('?? ?ang upload file local:', path.basename(img.path));
          const mediaId = await client.v1.uploadMedia(img.path);
          mediaIds.push(mediaId);
          console.log('???? upload file local l��n Twitter, Media ID:', mediaId);
        } catch (error) {
          console.error('??L?i upload file local:', error);
          // Continue with other files if one fails
        }
      }
    }
    
    // Post tweet with media
    const tweetOptions = { text };
    if (mediaIds.length > 0) {
      tweetOptions.media = { media_ids: mediaIds };
    }
    
    console.log('?? ?ang ??ng tweet l��n Twitter...');
    const tweet = await client.v2.tweet(tweetOptions);
    console.log('???? ??ng tweet th��nh c?ng! Tweet ID:', tweet.data.id);
    
    // Clean up uploaded files only (no downloaded files to clean)
    console.log('?????ang x��a c��c file ?? upload...');
    for (const file of uploadedFiles) {
      try {
        await fs.unlink(file.path);
        console.log('???? x��a file upload:', path.basename(file.path));
      } catch (e) {
        console.warn('?? Kh?ng th??x��a file upload:', e.message);
      }
    }
    console.log('?? Ho��n t?t! Kh?ng c?n t?i file t?m.');
    
    res.json({ 
      success: true, 
      tweetId: tweet.data.id,
      message: mediaIds.length > 0 
        ? `?? ??ng tweet k��m ${mediaIds.length} ?nh th��nh c?ng`
        : '?? ??ng tweet th��nh c?ng',
      imageCount: mediaIds.length
    });
  } catch (error) {
    console.error('??Twitter API Error:', error);
    
    // Clean up files on error - only uploaded files (no downloaded files)
    console.log('?????ang x��a c��c file do l?i x?y ra...');
    for (const file of uploadedFiles) {
      try {
        await fs.unlink(file.path);
        console.log('???? x��a file upload:', path.basename(file.path));
      } catch (e) {
        console.warn('?? Kh?ng th??x��a file upload:', e.message);
      }
    }
    
    res.status(500).json({ 
      success: false, 
      error: error.message || 'L?i khi ??ng tweet' 
    });
  }
});

// API: Auto post from DOCX
app.post('/api/twitter/auto-post', async (req, res) => {
  try {
    const data = await getContentFromDocx();
    const config = await loadConfig();
    
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ success: false, error: 'Not configured h��nh kh��a Twitter' });
    }

    const client = createTwitterClient(config);
    const tweet = await client.v2.tweet(data.content);
    
    res.json({ 
      success: true, 
      tweetId: tweet.data.id,
      message: `?? t????ng ??ng b��i t??${data.fileName}`
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint: fetch first article from external API and return title + up to 4 images
app.get('/external/first', async (req, res) => {
  try {
    // Allow passing api url via query ?url=..., otherwise use provided default
    const apiUrl = req.query.url || 'https://beiyong.slapibf.com/api.php/provide/art/?ac=detail&pg=1&t=72';
    const data = await fetchFirstArticleFromApi(apiUrl);
    res.json({ success: true, data });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint: fetch first article and post it to Twitter (requires keys configured)
app.post('/external/post-first', async (req, res) => {
  try {
    const apiUrl = req.body.url || 'https://beiyong.slapibf.com/api.php/provide/art/?ac=detail&pg=1&t=72';
    const article = await fetchFirstArticleFromApi(apiUrl);

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ success: false, error: 'Not configured h��nh kh��a Twitter' });
    }

    const client = createTwitterClient(config);

    // Upload images directly to Twitter without saving to disk
    const mediaIds = [];

    for (const url of (article.imageUrls || []).slice(0, 2)) {
      try {
        console.log('???ang upload ?nh tr?c ti?p t??URL (external):', url);
        const response = await axios.get(url, { 
          responseType: 'arraybuffer', 
          timeout: 15000, 
          headers: { 'User-Agent': 'Mozilla/5.0' } 
        });

        // Upload directly to Twitter without saving to disk
        const mimeType = getMimeTypeFromResponse(response, url);
        const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(external)');
        mediaIds.push(mediaId);
      } catch (err) {
        console.warn('??Kh?ng th??upload ?nh t??URL:', url, err.message);
      }
    }

    // Post tweet
    const tweetOptions = { text: article.art_name };
    if (mediaIds.length) tweetOptions.media = { media_ids: mediaIds };

    const tweet = await client.v2.tweet(tweetOptions);

    res.json({ success: true, tweetId: tweet.data.id, imageCount: mediaIds.length });
  } catch (error) {
    console.error('Error posting external first article:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// --- Multi-article fetch and scheduling ---

// Fetch multiple articles from API (tries to find array of objects with art_name + art_content)
async function fetchArticlesFromApi(apiUrl, limit = 20) {
  const res = await axios.get(apiUrl, { timeout: 15000 });
  const body = res.data;

  const results = [];

  function extractFromObject(obj) {
    if (!obj || typeof obj !== 'object') return;
    if (obj.art_name && obj.art_content) {
      const $ = cheerio.load(obj.art_content || '');
      const imgs = [];
      $('img').each((i, el) => { const src = $(el).attr('src'); if (src) imgs.push(src); });
      results.push({ art_name: obj.art_name, art_content: obj.art_content, imageUrls: imgs.slice(0, 2) });
      return;
    }
    for (const k of Object.keys(obj)) {
      const v = obj[k];
      if (Array.isArray(v)) {
        for (const item of v) {
          if (results.length >= limit) return;
          extractFromObject(item);
        }
      } else if (typeof v === 'object') {
        if (results.length >= limit) return;
        extractFromObject(v);
      }
      if (results.length >= limit) return;
    }
  }

  extractFromObject(body);

  return results.slice(0, limit);
}

// Generate extra short text (caption/hashtags) using OpenRouter
async function generateExtraContent(article) {
  if (!OPENROUTER_KEY) throw new Error('OpenRouter API key not configured');

  const title = article.art_name || '';
  const content = (article.art_content || '').replace(/<[^>]+>/g, ' ');

  const prompt = `B?n l�� m?t tr??ly vi?t Content required ng?n cho Twitter b?ng ti?ng Vi?t. D?a v��o title?? "${title}" v�� Content required: "${content}", h?y t?o: (1) m?t caption ng?n 1-2 cau, (2) 3 hashtag ph�� h?p. Tr??v????d?ng: caption newline hashtags (v�� d?? #tag1 #tag2 #tag3). Kh?ng th��m gi?i th��ch kh��c.`;

  const payload = {
    model: OPENROUTER_MODEL,
    messages: [
      { role: 'system', content: 'B?n l�� m?t tr??ly vi?t Content required ng?n, s��c t��ch.' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.8,
    max_tokens: 200
  };

  const resp = await axios.post('https://api.openrouter.ai/v1/chat/completions', payload, {
    headers: {
      'Authorization': `Bearer ${OPENROUTER_KEY}`,
      'Content-Type': 'application/json'
    },
    timeout: 20000
  });

  // Response format: choices[0].message.content
  const text = resp.data && resp.data.choices && resp.data.choices[0] && (resp.data.choices[0].message ? resp.data.choices[0].message.content : resp.data.choices[0].text);
  return (text || '').trim();
}

// Generate full rewritten title and full content using OpenRouter
async function generateFullContent(article) {
  if (!OPENROUTER_KEY) throw new Error('OpenRouter API key not configured');

  const title = article.art_name || '';
  const content = (article.art_content || '').replace(/<[^>]+>/g, ' ');

  const prompt = `B?n l�� m?t tr??ly vi?t l?i b��i b?ng ti?ng Vi?t. D?a tr��n title?? "${title}" v�� Content required hi?n c��: "${content}", h?y:
1) Vi?t l?i m?t title??m?i, b?t m?t v�� ph�� h?p cho Twitter.
2) Vi?t l?i Content required b��i ??y ??? m?ch l?c, ?o?n v?n r? r��ng, d��ng ng?n ng??t??nhi��n, d��i kho?ng 3-6 ?o?n.
Tr??v??k?t qu????d?ng JSON ch??g?m hai tr??ng: {"new_title":"...","full_content":"..."} v�� kh?ng c�� gi?i th��ch kh��c.`;

  const payload = {
    model: OPENROUTER_MODEL,
    messages: [
      { role: 'system', content: 'B?n l�� m?t tr??ly vi?t l?i b��i chuy��n nghi?p, s��ng t?o, b?ng ti?ng Vi?t.' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.8,
    max_tokens: 1200
  };

  const resp = await axios.post('https://api.openrouter.ai/v1/chat/completions', payload, {
    headers: {
      'Authorization': `Bearer ${OPENROUTER_KEY}`,
      'Content-Type': 'application/json'
    },
    timeout: 60000
  });

  const text = resp.data && resp.data.choices && resp.data.choices[0] && (resp.data.choices[0].message ? resp.data.choices[0].message.content : resp.data.choices[0].text);
  if (!text) throw new Error('OpenRouter returned empty response');

  // Try to parse JSON from model output; if model wraps with markdown or text, try to extract JSON substring
  let parsed = null;
  try {
    parsed = JSON.parse(text.trim());
  } catch (e) {
    // attempt to find first { ... } block
    const m = text.match(/\{[\s\S]*\}/);
    if (m) {
      try { parsed = JSON.parse(m[0]); } catch (e2) { /* fallthrough */ }
    }
  }

  if (!parsed) {
    // Fallback: return text as full_content and keep original title
    return { new_title: title, full_content: text.trim() };
  }

  return { new_title: parsed.new_title || title, full_content: parsed.full_content || '' };
}

// Post a single article object {art_name, imageUrls[]} to Twitter, return result
async function postArticleToTwitter(article, config, options = {}) {
  const client = createTwitterClient(config);

  const mediaIds = [];

  for (const url of (article.imageUrls || []).slice(0, 2)) {
    try {
      console.log('???ang upload ?nh tr?c ti?p t??URL (postArticleToTwitter):', url);
      const response = await axios.get(url, { 
        responseType: 'arraybuffer', 
        timeout: 15000, 
        headers: { 'User-Agent': 'Mozilla/5.0' } 
      });

      // Upload directly to Twitter without saving to disk
      const mimeType = getMimeTypeFromResponse(response, url);
      const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(postArticleToTwitter)');
      mediaIds.push(mediaId);
      
      // small delay between uploads to be gentle
      await new Promise(r => setTimeout(r, 300));
    } catch (err) {
      console.warn('??Kh?ng th??upload ?nh t??URL:', url, err.message);
    }
  }

  // Optionally generate extra content via OpenRouter
  let extraText = '';
  if (options.generate && OPENROUTER_KEY) {
    try {
      extraText = await generateExtraContent(article);
    } catch (e) {
      console.warn('OpenRouter generation failed:', e.message);
      extraText = '';
    }
  }

  // Compose tweet text: title + extra (ensure <= 280 chars)
  let tweetText = article.art_name || '';
  if (extraText) tweetText += '\n\n' + extraText;
  if (tweetText.length > 280) {
    // truncate extraText first
    const allowedExtra = 280 - (article.art_name || '').length - 2;
    if (allowedExtra > 0) {
      tweetText = (article.art_name || '') + '\n\n' + extraText.slice(0, allowedExtra - 3) + '...';
    } else {
      tweetText = tweetText.slice(0, 277) + '...';
    }
  }

  const tweetOptions = { text: tweetText };
  if (mediaIds.length) tweetOptions.media = { media_ids: mediaIds };

  const tweet = await client.v2.tweet(tweetOptions);

  return { tweetId: tweet.data.id, imageCount: mediaIds.length };
}



// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ 
    success: false, 
    error: process.env.NODE_ENV === 'production' ? 'Internal Server Error' : err.message 
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>404 - Not Found</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        h1 { color: #1da1f2; }
      </style>
    </head>
    <body>
      <h1>404 - Page Not Found</h1>
      <p>The page you're looking for doesn't exist.</p>
      <a href="/">Go to Home</a> | <a href="/twitter">Twitter Manager</a>
    </body>
    </html>
  `);
});

const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`?? Server ?ang ch?y t?i port ${PORT}`);
  console.log(`?? Qu?n ly Twitter: /twitter`);
  console.log(`?? Xem DOCX: /docx`);
  console.log(`?? Environment: ${process.env.NODE_ENV || 'development'}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Process terminated');
  });
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  server.close(() => {
    console.log('Process terminated');
  });
});
