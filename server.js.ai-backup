const express = require('express');
const session = require('express-session');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const multer = require('multer');
const axios = require('axios');
const { TwitterApi } = require('twitter-api-v2');
const OpenAI = require('openai');
const cron = require('node-cron');
const moment = require('moment');
require('dotenv').config();
const cheerio = require('cheerio');
const dataManager = require('./data-manager');
const schedulerManager = require('./scheduler-manager');

// Removed OpenRouter - now using Google Gemini for AI features

const app = express();
const PORT = process.env.PORT || 3000;

// Ensure uploads directory exists
const uploadDir = path.join(__dirname, 'uploads');
if (!fsSync.existsSync(uploadDir)) {
  fsSync.mkdirSync(uploadDir, { recursive: true });
}

// Multer configuration for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'image-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit per file
  fileFilter: function (req, file, cb) {
    const allowedTypes = /jpeg|jpg|png|gif|webp/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Chá»‰ cháº¥p nháº­n file áº£nh (JPEG, PNG, GIF, WebP)'));
    }
  }
});

// Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(session({
  secret: process.env.SESSION_SECRET || 'twitter-secret-key-2024',
  resave: false,
  saveUninitialized: true,
  cookie: { secure: false }
}));

// Set view engine with UTF-8 support
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Ensure UTF-8 encoding for all responses
app.use((req, res, next) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  next();
});

// Static files
app.use(express.static('public'));

// Config file path
const CONFIG_FILE = path.join(__dirname, 'twitter-config.json');

// OpenRouter AI client
const openai = new OpenAI({
  baseURL: "https://openrouter.ai/api/v1",
  apiKey: process.env.OPENROUTER_API_KEY,
});

// OpenRouter API key constant
const OPENROUTER_KEY = process.env.OPENROUTER_API_KEY;

// Scheduled tweets storage (server-side scheduling since Twitter API v2 doesn't support native scheduling)
let scheduledTweets = [];
let scheduledJobs = new Map();

// Helper function to download and upload image from URL (direct buffer upload - no file saving)
async function downloadAndUploadImage(client, imageUrl, context = '') {
  console.log(`ğŸ“¥ Downloading and uploading image directly ${context}: ${imageUrl}`);
  
  try {
    // Download image
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 15000,
      headers: { 
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'image/*,*/*;q=0.8'
      },
      maxContentLength: 5 * 1024 * 1024 // 5MB limit
    });

    // Validate response
    if (!response.data || response.data.length === 0) {
      throw new Error('Empty response data');
    }

    // Validate image data
    const buffer = Buffer.from(response.data);
    const contentType = response.headers['content-type'] || '';
    validateImageData(buffer, contentType, imageUrl);

    console.log(`ğŸ“¥ Downloaded valid image ${context}: ${buffer.length} bytes, Content-Type: ${contentType}`);

    // Upload to Twitter
    const mimeType = getMimeTypeFromResponse(response, imageUrl);
    const mediaId = await uploadImageToTwitter(client, buffer, mimeType, context);
    
    console.log(`âœ… Successfully processed image ${context} from URL: ${imageUrl}`);
    return mediaId;
    
  } catch (error) {
    console.error(`âŒ Failed to process image ${context} from URL: ${imageUrl}`);
    console.error(`âŒ Error: ${error.message}`);
    throw error;
  }
}

// Helper function to validate image data
function validateImageData(buffer, contentType, url) {
  // Validate content type
  if (!contentType || !contentType.startsWith('image/')) {
    throw new Error(`Invalid content type: ${contentType} (expected image/*)`);
  }

  // Validate file size (minimum 1KB to avoid QR codes or tiny images)
  if (buffer.length < 1024) {
    throw new Error(`Image too small: ${buffer.length} bytes (minimum 1KB)`);
  }

  // Check for HTML content (QR code pages often return HTML)
  const firstBytes = buffer.toString('utf8', 0, Math.min(100, buffer.length));
  if (firstBytes.includes('<html') || firstBytes.includes('<!DOCTYPE')) {
    throw new Error('Response contains HTML instead of image data');
  }

  // Check for common QR code indicators
  const urlLower = url.toLowerCase();
  if (urlLower.includes('qr') || urlLower.includes('code')) {
    console.warn('âš ï¸ URL may contain QR code:', url);
  }

  return true;
}

// Helper function to determine MIME type from response or URL
function getMimeTypeFromResponse(response, url) {
  let mimeType = 'image/jpeg'; // default
  const contentType = response.headers['content-type'];
  
  if (contentType && contentType.startsWith('image/')) {
    mimeType = contentType;
    console.log(`ğŸ“‹ MIME type from Content-Type header: ${mimeType}`);
  } else {
    // Guess from URL extension
    const urlLower = url.toLowerCase();
    if (urlLower.includes('.png')) mimeType = 'image/png';
    else if (urlLower.includes('.gif')) mimeType = 'image/gif';
    else if (urlLower.includes('.webp')) mimeType = 'image/webp';
    else if (urlLower.includes('.bmp')) mimeType = 'image/bmp';
    else if (urlLower.includes('.jpg') || urlLower.includes('.jpeg')) mimeType = 'image/jpeg';
    
    console.log(`ğŸ“‹ MIME type from URL extension: ${mimeType} (URL: ${url})`);
  }
  
  // Ensure we have a valid MIME type
  if (!mimeType || !mimeType.startsWith('image/')) {
    mimeType = 'image/jpeg';
    console.log(`ğŸ“‹ Fallback to default MIME type: ${mimeType}`);
  }
  
  return mimeType;
}

// Helper function to upload image buffer to Twitter (direct buffer upload - no file saving)
async function uploadImageToTwitter(client, imageBuffer, mimeType, context = '') {
  // Validate buffer
  if (!Buffer.isBuffer(imageBuffer) || imageBuffer.length === 0) {
    throw new Error('Invalid image buffer');
  }
  
  console.log(`ğŸ“¤ Uploading image directly ${context}: ${mimeType}, ${imageBuffer.length} bytes`);
  
  try {
    // Direct buffer upload to Twitter (no file saving)
    const mediaId = await client.v1.uploadMedia(imageBuffer, { mimeType });
    console.log(`âœ… Direct buffer upload successful ${context}, Media ID:`, mediaId);
    return mediaId;
    
  } catch (bufferError) {
    console.error(`âŒ Direct buffer upload failed ${context}:`, bufferError.message);
    
    // Fallback: Try without mimeType parameter
    try {
      console.log(`ğŸ”„ Trying buffer upload without mimeType ${context}...`);
      const mediaId = await client.v1.uploadMedia(imageBuffer);
      console.log(`âœ… Buffer upload without mimeType successful ${context}, Media ID:`, mediaId);
      return mediaId;
    } catch (fallbackError) {
      console.error(`âŒ All buffer upload methods failed ${context}:`, fallbackError.message);
      throw new Error(`Upload failed ${context}: ${bufferError.message}`);
    }
  }
}

// Load Twitter config
async function loadConfig() {
  try {
    const data = await fs.readFile(CONFIG_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return {
      appKey: '',
      appSecret: '',
      accessToken: '',
      accessSecret: ''
    };
  }
}

// Save Twitter config
async function saveConfig(config) {
  await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
}

// Check if Twitter keys are configured
function hasTwitterKeys(config) {
  return !!(config.appKey && config.appSecret && config.accessToken && config.accessSecret);
}

// Create Twitter client
function createTwitterClient(config) {
  return new TwitterApi({
    appKey: config.appKey,
    appSecret: config.appSecret,
    accessToken: config.accessToken,
    accessSecret: config.accessSecret,
  });
}

// Parse and format AI content to proper display format
function parseAndFormatAIContent(rawContent) {
  try {
    // Remove any markdown formatting or extra brackets
    let content = rawContent.replace(/\[|\]/g, '').trim();
    
    // Split content into lines and filter out empty lines
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    
    if (lines.length === 0) {
      throw new Error('Empty AI content');
    }
    
    let mainContent = '';
    let linkContent = '';
    let hashtags = '';
    
    // Parse different sections
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines
      if (!line) continue;
      
      // Check if line contains hashtags (starts with # or contains multiple #)
      if (line.includes('#') && (line.startsWith('#') || (line.match(/#/g) || []).length >= 2)) {
        hashtags = line;
      }
      // Check if line contains 6868.run
      else if (line.includes('6868.run')) {
        linkContent = line;
      }
      // Otherwise it's main content
      else if (!mainContent) {
        mainContent = line;
      }
    }
    
    // Build final formatted content
    let finalContent = '';
    
    // Add main content
    if (mainContent) {
      finalContent += mainContent;
    }
    
    // Add link content
    if (linkContent) {
      finalContent += '\n\n' + linkContent;
    } else {
      // Fallback link if not generated
      finalContent += '\n\nğŸ¯ å‘ç°æ›´å¤šç²¾å½©å†…å®¹ 6868.run';
    }
    
    // Add hashtags
    if (hashtags) {
      finalContent += '\n\n' + hashtags;
    } else {
      // Fallback hashtags if not generated
      finalContent += '\n\n#ç²¾å“ #æ¨è #çƒ­é—¨ #æ”¶è— #åˆ†äº«';
    }
    
    console.log('ğŸ“‹ è§£æç»“æœ:', {
      mainContent,
      linkContent,
      hashtags,
      finalContent: finalContent.substring(0, 100) + '...'
    });
    
    return finalContent;
    
  } catch (error) {
    console.error('âŒ è§£æAIå†…å®¹å¤±è´¥:', error);
    // Return raw content if parsing fails
    return rawContent;
  }
}

// Generate Chinese content based on title using AI
// Removed generateChineseContentFromTitle function - using predefined content only

    const prompt = `è¯·ä¸ºä»¥ä¸‹å†…å®¹åˆ›ä½œç¤¾äº¤åª’ä½“æ¨å¹¿æ–‡æ¡ˆï¿½?${title}"

è¦æ±‚ï¿½?
1. ä¸»è¦æ–‡æ¡ˆï¿½?5-35å­—ï¼‰ï¼šå›´ç»•å†…å®¹ä¸»é¢˜ï¼Œä½¿ç”¨1-2ä¸ªemojiï¼Œè¯­è¨€ç§¯ææ­£é¢
2. è®¿é—®å¼•å¯¼ï¿½?5-20å­—ï¼‰ï¼šåˆ›æ„å¼•å¯¼ç”¨æˆ·è®¿ï¿½?868.run
3. ç›¸å…³æ ‡ç­¾ï¿½?-5ä¸ªä¸­æ–‡hashtag

è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¿”å›ï¿½?
ğŸŒŸ [ä¸»è¦æ¨å¹¿æ–‡æ¡ˆ]

ğŸ”— [è®¿é—®å¼•å¯¼æ–‡æ¡ˆ] 6868.run  

#æ ‡ç­¾1 #æ ‡ç­¾2 #æ ‡ç­¾3 #æ ‡ç­¾4 #æ ‡ç­¾5`;

    const completion = await openai.chat.completions.create({
      model: "anthropic/claude-3-haiku",
      messages: [
        {
          role: "system",
          content: "ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ç¤¾äº¤åª’ä½“å†…å®¹åˆ›ä½œè€…ï¼Œæ“…é•¿ä¸ºå„ç§ä¸»é¢˜åˆ›ä½œç§¯ææ­£é¢çš„æ¨å¹¿æ–‡æ¡ˆã€‚è¯·åˆ›ä½œç¬¦åˆè¦æ±‚çš„å†…å®¹ï¼Œä½¿ç”¨åˆ›æ„å’Œå¸å¼•äººçš„è¯­è¨€ã€‚"
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 100,
      temperature: 0.7
    });

    const rawContent = completion.choices[0].message.content.trim();
    console.log('ğŸ¤– AIç”ŸæˆåŸå§‹å†…å®¹:', rawContent);
    
    // Check if AI refused to generate content
    const refusalKeywords = ['æŠ±æ­‰', 'æ— æ³•', 'ä¸èƒ½', 'ä¸ä¼š', 'æ‹’ç»', 'ä¸é€‚åˆ', 'è¿å', 'æ”¿ç­–'];
    const isRefusal = refusalKeywords.some(keyword => rawContent.includes(keyword));
    
    if (isRefusal) {
      console.log('âš ï¸ AIæ‹’ç»ç”Ÿæˆå†…å®¹ï¼Œä½¿ç”¨fallbackæ¨¡æ¿');
      return getRandomChineseContent();
    }
    
    // Parse and format the AI content properly
    const formattedContent = parseAndFormatAIContent(rawContent);
    console.log('âœ… AIæ ¼å¼åŒ–åå†…å®¹:', formattedContent);
    
    return formattedContent;
  } catch (error) {
    console.error('âŒ Lá»—i táº¡o ná»™i dung AI:', error);
    
    // Fallback to simple template if AI fails
    return getRandomChineseContent();
  }
}

// Schedule tweet function using server-side cron job (Twitter API v2 doesn't support native scheduling)
function scheduleTweet(tweetData, scheduledTime) {
  const tweetId = Date.now() + Math.random();
  
  // Parse scheduled time
  const scheduleDate = new Date(scheduledTime);
  const now = new Date();
  
  // Check if time is in the future
  if (scheduleDate <= now) {
    console.error('??Th?i gian l?p l?ch ph?i trong t??ng lai:', scheduleDate, 'hi?n t?i:', now);
    throw new Error('Th?i gian l?p l?ch ph?i trong t??ng lai');
  }
  
  // Create cron format: second minute hour day month dayOfWeek
  const cronTime = `${scheduleDate.getSeconds()} ${scheduleDate.getMinutes()} ${scheduleDate.getHours()} ${scheduleDate.getDate()} ${scheduleDate.getMonth() + 1} *`;
  
  console.log('ğŸ“… Láº­p lá»‹ch tweet (server-side):', {
    id: tweetId,
    scheduledTime: scheduleDate.toLocaleString('vi-VN'),
    cronFormat: cronTime,
    content: tweetData.text.substring(0, 50) + '...',
    timeUntil: Math.round((scheduleDate.getTime() - now.getTime()) / 1000 / 60) + ' phÃºt'
  });

  // T?o cron job
  const job = cron.schedule(cronTime, async () => {
    try {
      console.log('ğŸš€ Äang Ä‘Äƒng tweet theo lá»‹ch:', tweetId, 'vÃ o lÃºc:', new Date().toLocaleString('vi-VN'));
      await postScheduledTweet(tweetData);
      
      // Xï¿½ï¿½a job sau khi hoï¿½ï¿½n thï¿½ï¿½nh
      scheduledJobs.delete(tweetId);
      scheduledTweets = scheduledTweets.filter(t => t.id !== tweetId);
      console.log('âœ… ÄÃ£ hoÃ n thÃ nh vÃ  xÃ³a job:', tweetId);
      
    } catch (error) {
      console.error('âŒ Lá»—i Ä‘Äƒng tweet theo lá»‹ch:', tweetId, error);
    }
  }, {
    scheduled: true, // Start immediately
    timezone: 'Asia/Ho_Chi_Minh' // Set timezone
  });

  // L?u th?ng tin
  const scheduledTweet = {
    id: tweetId,
    ...tweetData,
    scheduledTime: scheduledTime,
    status: 'scheduled',
    createdAt: new Date(),
    cronFormat: cronTime
  };

  scheduledTweets.push(scheduledTweet);
  scheduledJobs.set(tweetId, job);
  
  console.log('âœ… ÄÃ£ táº¡o cron job thÃ nh cÃ´ng:', tweetId);
  
  return tweetId;
}

// Post scheduled tweet
async function postScheduledTweet(tweetData) {
  const config = await loadConfig();
  if (!hasTwitterKeys(config)) {
    throw new Error('ChÆ°a cáº¥u hÃ¬nh khÃ³a Twitter');
  }

  const client = createTwitterClient(config);
  let mediaIds = [];
  
  // Handle images if any - upload directly without saving
  if (tweetData.imageUrls && tweetData.imageUrls.length > 0) {
    for (const url of tweetData.imageUrls.slice(0, 4)) {
      try {
        const mediaId = await downloadAndUploadImage(client, url, '(scheduled)');
        mediaIds.push(mediaId);
        
      } catch (error) {
        console.error('??L?i x??ly ?nh trong tweet l?p l?ch:', error);
        // Continue with other images if one fails
      }
    }
  }

  // Post tweet
  const tweetOptions = { text: tweetData.text };
  if (mediaIds.length > 0) {
    tweetOptions.media = { media_ids: mediaIds };
  }
  
  const tweet = await client.v2.tweet(tweetOptions);
  console.log('âœ… ÄÄƒng tweet theo lá»‹ch thÃ nh cÃ´ng! Tweet ID:', tweet.data.id);
  
  return tweet;
}



// Fetch page data with titles and images from API
async function fetchPageDataFromAPI(apiUrl) {
  try {
    console.log('ğŸ“¡ Äang láº¥y dá»¯ liá»‡u tá»« API:', apiUrl);
    const response = await axios.get(apiUrl, {
      timeout: 10000,
      headers: { 'User-Agent': 'Mozilla/5.0' }
    });
    
    console.log('ğŸ“‹ Cáº¥u trÃºc API response:', Object.keys(response.data));
    
    let articles = [];
    
    // Ki?m tra c?u trï¿½ï¿½c API c??th??cho beiyong.slapibf.com
    if (response.data.list && Array.isArray(response.data.list)) {
      console.log('ğŸ“‹ TÃ¬m tháº¥y field "list" vá»›i', response.data.list.length, 'items');
      articles = response.data.list.map(item => {
        const title = item.art_name || item.title || item.name || item.headline || 'No title';
        
        // L?y hï¿½ï¿½nh ?nh t??nhi?u ngu?n
        let images = [];
        
        // 1. T??art_pic
        if (item.art_pic) {
          if (typeof item.art_pic === 'string') {
            // N?u lï¿½ï¿½ string, cï¿½ï¿½ th??ch?a nhi?u URL phan cï¿½ï¿½ch b?i d?u ph?y, |, ho?c xu?ng dï¿½ï¿½ng
            const imageUrls = item.art_pic.split(/[,|\n]/).map(url => url.trim()).filter(url => url && url.startsWith('http'));
            images = images.concat(imageUrls);
          } else if (Array.isArray(item.art_pic)) {
            images = images.concat(item.art_pic.filter(url => url && url.startsWith('http')));
          }
        }
        
        // 2. Tá»« art_content (chá»‰ láº¥y URL tá»« thuá»™c tÃ­nh src cá»§a tháº» img)
        if (item.art_content) {
          const $ = cheerio.load(item.art_content);
          $('img').each((i, el) => {
            const src = $(el).attr('src');
            if (src && src.startsWith('http')) {
              images.push(src);
            }
          });
        }
        
        // 3. Tá»« cÃ¡c field khÃ¡c cÃ³ thá»ƒ chá»©a áº£nh
        ['art_thumb', 'art_logo', 'art_cover', 'thumb', 'cover', 'image'].forEach(field => {
          if (item[field] && typeof item[field] === 'string' && item[field].startsWith('http')) {
            images.push(item[field]);
          }
        });
        
        // Filter out unwanted watermarked images and remove duplicates
        images = [...new Set(images)]
          .filter(url => {
            // Remove images with unwanted watermarks
            const unwantedDomains = ['1024xp.com', '1024ç¤¾åŒº', 'watermark'];
            return !unwantedDomains.some(domain => url.toLowerCase().includes(domain.toLowerCase()));
          })
          .slice(0, 4); // Take up to 4 images
        
        console.log(`ğŸ“‹ BÃ i "${title.substring(0, 30)}..." cÃ³ ${images.length} áº£nh:`, images.slice(0, 2));
        
        return {
          title: title.replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').trim(),
          images: images,
          originalData: item
        };
      });
    } else {
      throw new Error('API kh?ng tr??v??c?u trï¿½ï¿½c d??li?u mong ??i');
    }
    
    console.log('âœ… ÄÃ£ láº¥y Ä‘Æ°á»£c', articles.length, 'bÃ i viáº¿t');
    console.log('ğŸ“‹ BÃ i viáº¿t Ä‘áº§u tiÃªn:', articles[0]?.title, '- Sá»‘ áº£nh:', articles[0]?.images?.length || 0);
    
    return articles;
  } catch (error) {
    console.error('âŒ Lá»—i láº¥y dá»¯ liá»‡u tá»« API:', error);
    throw new Error('Kh?ng th??l?y d??li?u t??API: ' + error.message);
  }
}

// Fetch first article from an external API URL and extract title + image URLs
async function fetchFirstArticleFromApi(apiUrl) {
  const res = await axios.get(apiUrl, { timeout: 15000 });
  const body = res.data;

  // Try to find an object that contains art_name and art_content
  function findArticle(obj) {
    if (!obj || typeof obj !== 'object') return null;
    if (obj.art_name && obj.art_content) return obj;
    for (const k of Object.keys(obj)) {
      const v = obj[k];
      if (Array.isArray(v)) {
        for (const item of v) {
          const found = findArticle(item);
          if (found) return found;
        }
      } else if (typeof v === 'object') {
        const found = findArticle(v);
        if (found) return found;
      }
    }
    return null;
  }

  const article = findArticle(body);
  if (!article) throw new Error('KhÃ´ng tÃ¬m tháº¥y bÃ i viáº¿t (art_name / art_content) trong pháº£n há»“i API');

  const artName = article.art_name;
  const artContent = article.art_content || '';

  // Parse HTML and extract image src attributes
  const $ = cheerio.load(artContent);
  const imgs = [];
  $('img').each((i, el) => {
    const src = $(el).attr('src');
    if (src) imgs.push(src);
  });

  // Return title and up to 4 image URLs
  return {
    art_name: artName,
    imageUrls: imgs.slice(0, 4)
  };
}

// Read content from DOCX files
async function getContentFromDocx() {
  try {
    const docxDir = path.join(__dirname, 'docx');
    const files = await fs.readdir(docxDir);
    const docxFiles = files.filter(f => f.endsWith('.docx'));
    
    if (docxFiles.length === 0) {
      throw new Error('KhÃ´ng tÃ¬m tháº¥y file DOCX nÃ o');
    }

    // For now, we'll return a placeholder
    // You can integrate mammoth.js or docx library to extract text
    const fileName = docxFiles[0];
    return {
      fileName,
      content: `Ná»™i dung tá»± Ä‘á»™ng tá»« file ${fileName}. ÄÃ¢y lÃ  bÃ i viáº¿t Ä‘Æ°á»£c táº¡o tá»± Ä‘á»™ng tá»« há»‡ thá»‘ng.`
    };
  } catch (error) {
    throw new Error(`Lá»—i Ä‘á»c file DOCX: ${error.message}`);
  }
}





// Routes
app.get('/', (req, res) => {
  res.redirect('/dashboard');
});

// Dashboard route
app.get('/dashboard', async (req, res) => {
  res.render('dashboard', {
    title: 'Dashboard - Twitter Auto Post'
  });
});

// Redirect old twitter route to dashboard
app.get('/twitter', (req, res) => {
  res.redirect('/dashboard');
});

// Dashboard content routes
app.get('/dashboard/post-content', async (req, res) => {
  const cfg = await loadConfig();
  res.render('post-content', {
    cfg,
    hasKeys: hasTwitterKeys(cfg)
  });
});

app.get('/dashboard/settings-content', async (req, res) => {
  const cfg = await loadConfig();
  res.render('settings-content', {
    cfg,
    hasKeys: hasTwitterKeys(cfg)
  });
});

app.get('/docx', async (req, res) => {
  try {
    const docxDir = path.join(__dirname, 'docx');
    await fs.mkdir(docxDir, { recursive: true });
    const files = await fs.readdir(docxDir);
    const docxFiles = files.filter(f => f.endsWith('.docx'));
    
    res.send(`
      <!DOCTYPE html>
      <html lang="vi">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Danh sï¿½ï¿½ch DOCX</title>
        <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
          }
          .container { max-width: 800px; margin: 0 auto; }
          .header {
            background: white;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
          }
          h1 { color: #1da1f2; margin-bottom: 12px; }
          .file-list {
            background: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
          }
          .file-item {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
          }
          .file-item:last-child { border-bottom: none; }
          .file-name { font-weight: 500; color: #333; }
          .btn {
            padding: 8px 16px;
            background: #1da1f2;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>ğŸ“„ Danh sÃ¡ch file DOCX</h1>
            <a href="/" style="color: #666; text-decoration: none;">â† Quay láº¡i</a>
          </div>
          <div class="file-list">
            ${docxFiles.length ? docxFiles.map(f => `
              <div class="file-item">
                <span class="file-name">ğŸ“„ ${f}</span>
                <a href="#" class="btn">Xem Content required</a>
              </div>
            `).join('') : '<p style="text-align: center; color: #666;">ChÆ°a cÃ³ file DOCX nÃ o trong thÆ° má»¥c /docx</p>'}
          </div>
        </div>
      </body>
      </html>
    `);
  } catch (error) {
    res.status(500).send('Lá»—i: ' + error.message);
  }
});

// API: Dashboard statistics
app.get('/api/dashboard/stats', async (req, res) => {
  try {
    const stats = {
      totalTweets: await dataManager.getTotalTweetsCount(),
      todayTweets: await dataManager.getTodayTweetsCount(),
      scheduledTweets: await dataManager.getScheduledTweetsCount(),
      apiArticles: await dataManager.getApiArticlesCount(),
      recentActivity: await dataManager.getRecentActivity(10)
    };

    res.json(stats);
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// API: Save Twitter keys
app.post('/api/twitter/keys', async (req, res) => {
  try {
    const { appKey, appSecret, accessToken, accessSecret } = req.body;
    await saveConfig({ appKey, appSecret, accessToken, accessSecret });
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Removed AI content generation endpoint

// API: Fetch page data with titles and images
app.post('/api/fetch-page-data', async (req, res) => {
  try {
    const { apiUrl, limit } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Vui lÃ²ng nháº­p URL API' 
      });
    }

    const allArticles = await fetchPageDataFromAPI(apiUrl.trim());
    
    // Limit the number of articles if specified
    const limitNum = parseInt(limit) || allArticles.length;
    const articles = allArticles.slice(0, limitNum);
    
    res.json({ 
      success: true, 
      articles: articles,
      message: `ÄÃ£ láº¥y ${articles.length}/${allArticles.length} bÃ i viáº¿t tá»« API`
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Generate Chinese content from title
app.post('/api/ai/generate-content', async (req, res) => {
  try {
    const { title } = req.body;
    
    if (!title || title.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Vui lÃ²ng cung cáº¥p tiÃªu Ä‘á»' 
      });
    }

    const content = await generateChineseContentFromTitle(title.trim());
    
    res.json({ 
      success: true, 
      content: content,
      message: 'ÄÃ£ táº¡o ná»™i dung AI thÃ nh cÃ´ng'
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Bulk process 20 articles - fetch, generate AI content, and schedule posts
app.post('/api/bulk-process', async (req, res) => {
  try {
    const { apiUrl, page } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' 
      });
    }

    // Step 1: Fetch 1 article from API
    console.log('ğŸ“‹ BÆ°á»›c 1: Láº¥y 1 bÃ i tá»« API...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'KhÃ´ng láº¥y Ä‘Æ°á»£c bÃ i viáº¿t nÃ o tá»« API' 
      });
    }

    // Take only first 1 article as requested
    const selectedArticles = articles.slice(0, 1);
    console.log(`âœ… ÄÃ£ láº¥y ${selectedArticles.length} bÃ i viáº¿t`);

    // Step 2: Generate AI content for each article
    console.log('ğŸ“‹ BÆ°á»›c 2: Táº¡o ná»™i dungd AI cho t?ng bï¿½ï¿½i...');
    const processedArticles = [];
    
    for (let i = 0; i < selectedArticles.length; i++) {
      const article = selectedArticles[i];
      console.log(`?? X??ly bï¿½ï¿½i ${i + 1}/${selectedArticles.length}: ${article.title.substring(0, 30)}...`);
      
      try {
        // Generate AI content
        const aiContent = await generateChineseContentFromTitle(article.title);
        
        // Prepare tweet data
        // Take all 4 images from available images
        const selectedImages = article.images ? article.images.slice(0, 4) : [];
        
        const tweetData = {
          text: `${article.title}\n\n${aiContent}`,
          imageUrls: selectedImages // Take all 4 images
        };
        
        processedArticles.push({
          ...article,
          aiContent: aiContent,
          tweetData: tweetData
        });
        
        console.log(`??Hoï¿½ï¿½n thï¿½ï¿½nh bï¿½ï¿½i ${i + 1}`);
        
        // Small delay to avoid rate limiting
        if (i < selectedArticles.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
      } catch (error) {
        console.error(`??L?i x??ly bï¿½ï¿½i ${i + 1}:`, error);
        // Use fallback content if AI fails
        const fallbackContent = getRandomChineseContent();
        processedArticles.push({
          ...article,
          aiContent: fallbackContent,
          tweetData: {
            text: `${article.title}\n\n${fallbackContent}`,
            imageUrls: article.images ? article.images.slice(0, 4) : [] // Take all 4 images
          }
        });
      }
    }

    // Step 3: Schedule posts - 20 bï¿½ï¿½i chia 5 ngï¿½ï¿½y, m?i ngï¿½ï¿½y 4 bï¿½ï¿½i
    console.log('?? B??c 3: L?p l?ch ??ng bï¿½ï¿½i...');
    const scheduleResults = await scheduleArticlesBulk(processedArticles);
    
    res.json({ 
      success: true, 
      message: `?? x??ly vï¿½ï¿½ l?p l?ch ${processedArticles.length} bï¿½ï¿½i thï¿½ï¿½nh c?ng!`,
      articlesProcessed: processedArticles.length,
      scheduledTweets: scheduleResults.length,
      scheduleDetails: scheduleResults
    });

  } catch (error) {
    console.error('??L?i x??ly bulk:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Function to get random Chinese content (fallback)
function getRandomChineseContent() {
  const templates = [
    "ğŸŒŸ ç²¾å“å†…å®¹æ¨èï¼ä¼˜è´¨èµ„æºæ¯æ—¥æ›´æ–°\n\nğŸ¯ å‘ç°æ›´å¤šç²¾å½© 6868.run\n\n#ç²¾å“ #æ¨è #ä¼˜è´¨ #æ›´æ–° #æ”¶è—",
    "ï¿½?ç‹¬å®¶çè—ç‰ˆæœ¬ï¼è¶…æ¸…ç”»è´¨å®Œæ•´æ”¶å½•\n\nğŸ” æ¢ç´¢é¡¶çº§å“è´¨ 6868.run\n\n#ç‹¬å®¶ #çè— #è¶…æ¸… #å®Œæ•´ #å“è´¨",
    "ğŸ’ VIPä¸“å±èµ„æºï¼ä¼šå‘˜ç‹¬äº«ç‰¹æƒå†…å®¹\n\nğŸš€ æ¢ç´¢æ›´å¤šæƒŠå–œ 6868.run\n\n#VIP #ä¸“å± #ç‰¹æƒ #ä¼šå‘˜ #æƒŠå–œ",
    "ğŸ¯ çƒ­é—¨æ¨èç³»åˆ—ï¼ç½‘å‹å¼ºçƒˆæ¨èå†…å®¹\n\nğŸ’« ä½“éªŒç²¾å½©å†…å®¹ 6868.run\n\n#æ¨è #çƒ­é—¨ #ç²¾å½© #ä½“éªŒ #å†…å®¹",
    "ğŸ† ç²¾å“æ”¶è—å¿…å¤‡ï¼ç»å…¸æ°¸æ’ä¼˜è´¨ä½œå“\n\nğŸŒˆ å‘ç°ç²¾å½©ä½œå“ 6868.run\n\n#ç²¾å“ #æ”¶è— #ç»å…¸ #æ°¸æ’ #ä½œå“"
  ];
  return templates[Math.floor(Math.random() * templates.length)];
}

// Function to schedule articles in bulk (5 days, 4 posts per day)
async function scheduleArticlesBulk(articles) {
  const scheduleResults = [];
  const postsPerDay = 4;
  const timeSlots = ['08:00', '12:00', '17:00', '21:00']; // Sï¿½ï¿½ng, tr?a, chi?u, t?i
  
  // Start from tomorrow
  const startDate = new Date();
  startDate.setDate(startDate.getDate() + 1);
  startDate.setHours(0, 0, 0, 0);
  
  for (let i = 0; i < articles.length; i++) {
    const article = articles[i];
    const dayOffset = Math.floor(i / postsPerDay);
    const timeSlotIndex = i % postsPerDay;
    
    // Calculate schedule time
    const scheduleDate = new Date(startDate);
    scheduleDate.setDate(scheduleDate.getDate() + dayOffset);
    
    const [hours, minutes] = timeSlots[timeSlotIndex].split(':').map(Number);
    scheduleDate.setHours(hours, minutes, 0, 0);
    
    try {
      // Schedule the tweet
      const tweetId = scheduleTweet(article.tweetData, scheduleDate.toISOString());
      
      scheduleResults.push({
        articleIndex: i + 1,
        title: article.title.substring(0, 50) + '...',
        scheduledTime: scheduleDate.toISOString(),
        timeSlot: timeSlots[timeSlotIndex],
        day: dayOffset + 1,
        tweetId: tweetId,
        imageCount: article.tweetData.imageUrls.length
      });
      
      console.log(`?? ?? l?p l?ch bï¿½ï¿½i ${i + 1}: ${scheduleDate.toLocaleString('vi-VN')} (${timeSlots[timeSlotIndex]})`);
      
    } catch (error) {
      console.error(`??L?i l?p l?ch bï¿½ï¿½i ${i + 1}:`, error);
      scheduleResults.push({
        articleIndex: i + 1,
        title: article.title.substring(0, 50) + '...',
        error: error.message
      });
    }
  }
  
  return scheduleResults;
}

// API: Schedule tweet using server-side cron job
app.post('/api/twitter/schedule', async (req, res) => {
  try {
    const { text, imageUrls, scheduledTime } = req.body;
    
    if (!text || text.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Content required' 
      });
    }

    if (!scheduledTime) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide ch?n th?i gian ??ng' 
      });
    }

    // Ki?m tra th?i gian ph?i trong t??ng lai
    const scheduleDate = new Date(scheduledTime);
    if (scheduleDate <= new Date()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Th?i gian ??ng ph?i trong t??ng lai' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' 
      });
    }

    // Parse image URLs
    let parsedImageUrls = [];
    if (imageUrls && imageUrls.trim()) {
      parsedImageUrls = imageUrls.split('\n')
        .map(url => url.trim())
        .filter(url => url && url.startsWith('http'))
        .slice(0, 4);
    }

    const tweetData = {
      text: text.trim(),
      imageUrls: parsedImageUrls
    };

    const tweetId = scheduleTweet(tweetData, scheduledTime);
    
    res.json({ 
      success: true, 
      tweetId: tweetId,
      scheduledTime: scheduledTime,
      message: `?? l?p l?ch tweet (server-side) lï¿½ï¿½c ${moment(scheduledTime).format('DD/MM/YYYY HH:mm')}`
    });
  } catch (error) {
    console.error('??L?i l?p l?ch tweet:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Get scheduled tweets (server-side)
app.get('/api/twitter/scheduled', async (req, res) => {
  try {
    const tweets = await schedulerManager.getActiveScheduledTweets();
    
    res.json({ 
      success: true, 
      tweets: tweets 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Cancel scheduled tweet (server-side)
app.delete('/api/twitter/scheduled/:id', (req, res) => {
  try {
    const tweetId = parseInt(req.params.id);
    
    // Tï¿½ï¿½m vï¿½ï¿½ xï¿½ï¿½a job
    const job = scheduledJobs.get(tweetId);
    if (job) {
      job.stop();
      job.destroy();
      scheduledJobs.delete(tweetId);
      console.log('?????? h?y job:', tweetId);
    }
    
    // Xï¿½ï¿½a kh?i danh sï¿½ï¿½ch
    scheduledTweets = scheduledTweets.filter(t => t.id !== tweetId);
    
    res.json({ 
      success: true, 
      message: '?? h?y l?ch ??ng tweet' 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Test simple image upload
app.post('/api/test/simple-upload', async (req, res) => {
  try {
    const { imageUrl } = req.body;
    
    if (!imageUrl) {
      return res.status(400).json({ 
        success: false, 
        error: 'Vui lÃ²ng cung cáº¥p imageUrl' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'ChÆ°a cáº¥u hÃ¬nh khÃ³a Twitter' 
      });
    }

    const client = createTwitterClient(config);
    
    console.log('ğŸ§ª Simple test upload tï¿½?URL:', imageUrl);
    
    // Simple download and direct upload (no file saving)
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 15000,
      headers: { 'User-Agent': 'Mozilla/5.0' },
      maxContentLength: 5 * 1024 * 1024
    });

    const buffer = Buffer.from(response.data);
    console.log(`ğŸ“¥ Downloaded: ${buffer.length} bytes`);

    // Direct buffer upload to Twitter (no file saving)
    const mimeType = response.headers['content-type'] || 'image/jpeg';
    const mediaId = await client.v1.uploadMedia(buffer, { mimeType });
    console.log(`âœ… Direct upload successful! Media ID: ${mediaId}`);
    
    console.log(`ğŸš€ No temporary files created - direct buffer upload used`);
    
    res.json({
      success: true,
      mediaId: mediaId,
      imageSize: buffer.length,
      message: 'Direct buffer upload thÃ nh cÃ´ng - khÃ´ng táº¡o file táº¡m thá»i!'
    });

  } catch (error) {
    console.error('ï¿½?Simple test upload tháº¥t báº¡i:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Test image upload
app.post('/api/test/image-upload', async (req, res) => {
  try {
    const { imageUrl } = req.body;
    
    if (!imageUrl) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide imageUrl' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' 
      });
    }

    const client = createTwitterClient(config);
    
    console.log('ğŸ§ª Test upload áº£nh tï¿½?URL:', imageUrl);
    
    // Use the new download and upload function
    const mediaId = await downloadAndUploadImage(client, imageUrl, '(test)');
    
    // Get image info for response
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 15000,
      headers: { 'User-Agent': 'Mozilla/5.0' },
      maxContentLength: 5 * 1024 * 1024
    });
    
    const mimeType = getMimeTypeFromResponse(response, imageUrl);
    
    res.json({
      success: true,
      mediaId: mediaId,
      imageSize: response.data.length,
      mimeType: mimeType,
      message: 'Test direct buffer upload thÃ nh cÃ´ng!'
    });

  } catch (error) {
    console.error('??Test upload ?nh th?t b?i:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Debug scheduled jobs
app.get('/api/debug/jobs', (req, res) => {
  const jobsInfo = [];
  
  scheduledJobs.forEach((job, tweetId) => {
    const tweet = scheduledTweets.find(t => t.id === tweetId);
    jobsInfo.push({
      tweetId: tweetId,
      scheduledTime: tweet ? tweet.scheduledTime : 'Unknown',
      cronFormat: tweet ? tweet.cronFormat : 'Unknown',
      status: job.running ? 'Running' : 'Stopped',
      content: tweet ? tweet.text.substring(0, 50) + '...' : 'Unknown'
    });
  });
  
  res.json({
    success: true,
    totalJobs: scheduledJobs.size,
    totalTweets: scheduledTweets.length,
    currentTime: new Date().toLocaleString('vi-VN'),
    jobs: jobsInfo
  });
});

// API: Auto post 1 article immediately
app.post('/api/auto-post-now', async (req, res) => {
  try {
    const { apiUrl, page, limit } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Vui lÃ²ng nháº­p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'ChÆ°a cáº¥u hÃ¬nh khÃ³a Twitter' 
      });
    }

    // Step 1: Fetch 1 article from API
    console.log('ğŸ“¡ Láº¥y 1 bÃ i tá»« API Ä‘á»ƒ Ä‘Äƒng ngay...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'KhÃ´ng láº¥y Ä‘Æ°á»£c bÃ i viáº¿t nÃ o tá»« API' 
      });
    }

    // Take only first 1 article
    const article = articles[0];
    console.log(`ğŸ“‹ Äang xá»­ lÃ½ bÃ i: ${article.title.substring(0, 50)}...`);

    try {
      // Generate AI content
      console.log('ğŸ¤– Táº¡o ná»™i dung AI...');
      const aiContent = await generateChineseContentFromTitle(article.title);
      
      // Prepare tweet content
      const tweetText = `${article.title}\n\n${aiContent}`;
      
      // Create Twitter client
      const client = createTwitterClient(config);
      let mediaIds = [];
      
      // Upload images if available
      if (article.images && article.images.length > 0) {
        console.log(`ğŸ“¸ Upload ${article.images.length} áº£nh...`);
        
        for (let i = 0; i < Math.min(article.images.length, 4); i++) {
          try {
            const mediaId = await downloadAndUploadImage(client, article.images[i], `(${i+1}/4)`);
            mediaIds.push(mediaId);
          } catch (error) {
            console.error(`âŒ Lá»—i upload áº£nh ${i+1}:`, error.message);
            // Continue with other images
          }
        }
      }

      // Post tweet immediately
      console.log('ğŸš€ ÄÄƒng tweet ngay...');
      const tweetOptions = { text: tweetText };
      if (mediaIds.length > 0) {
        tweetOptions.media = { media_ids: mediaIds };
      }
      
      const tweet = await client.v2.tweet(tweetOptions);
      
      console.log('âœ… ÄÃ£ Ä‘Äƒng tweet thÃ nh cÃ´ng! Tweet ID:', tweet.data.id);
      
      res.json({ 
        success: true, 
        message: `ÄÃ£ Ä‘Äƒng bÃ i thÃ nh cÃ´ng vá»›i ${mediaIds.length} áº£nh!`,
        articlesProcessed: 1,
        scheduledTweets: 1,
        tweetId: tweet.data.id,
        imageCount: mediaIds.length,
        title: article.title.substring(0, 50) + '...'
      });
      
    } catch (error) {
      console.error('âŒ Lá»—i Ä‘Äƒng bÃ i:', error);
      res.status(500).json({ 
        success: false, 
        error: `Lá»—i Ä‘Äƒng bÃ i: ${error.message}` 
      });
    }

  } catch (error) {
    console.error('âŒ Lá»—i auto post now:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: Auto schedule 20 posts immediately
app.post('/api/auto-schedule-20', async (req, res) => {
  try {
    const { apiUrl, page } = req.body;
    
    if (!apiUrl || !apiUrl.trim()) {
      return res.status(400).json({ 
        success: false, 
        error: 'Please provide nh?p URL API' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' 
      });
    }

    // Step 1: Fetch 20 articles from API
    console.log('?? L?y 20 bï¿½ï¿½i t??API ???l?p l?ch...');
    const fullApiUrl = `${apiUrl}&pg=${page || 1}`;
    const articles = await fetchPageDataFromAPI(fullApiUrl);
    
    if (!articles || articles.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Kh?ng l?y ???c bï¿½ï¿½i vi?t nï¿½ï¿½o t??API' 
      });
    }

    // Take only first 20 articles
    const selectedArticles = articles.slice(0, 1);
    console.log(`???? l?y ${selectedArticles.length} bï¿½ï¿½i vi?t ???l?p l?ch`);

    // Step 2: Generate AI content and schedule immediately
    const scheduleResults = [];
    const postsPerDay = 4;
    const timeSlots = ['08:00', '12:00', '17:00', '21:00']; // Sï¿½ï¿½ng, tr?a, chi?u, t?i
    
    // Start from tomorrow
    const startDate = new Date();
    startDate.setDate(startDate.getDate() + 1);
    startDate.setHours(0, 0, 0, 0);
    
    for (let i = 0; i < selectedArticles.length; i++) {
      const article = selectedArticles[i];
      console.log(`?? X??ly vï¿½ï¿½ l?p l?ch bï¿½ï¿½i ${i + 1}/${selectedArticles.length}: ${article.title.substring(0, 30)}...`);
      
      try {
        // Generate AI content
        const aiContent = await generateChineseContentFromTitle(article.title);
        
        // Calculate schedule time
        const dayOffset = Math.floor(i / postsPerDay);
        const timeSlotIndex = i % postsPerDay;
        
        const scheduleDate = new Date(startDate);
        scheduleDate.setDate(scheduleDate.getDate() + dayOffset);
        
        const [hours, minutes] = timeSlots[timeSlotIndex].split(':').map(Number);
        scheduleDate.setHours(hours, minutes, 0, 0);
        
        // Prepare tweet data
        const tweetData = {
          text: `${article.title}\n\n${aiContent}`,
          imageUrls: article.images.slice(0, 4) // Take all 4 images
        };
        
        // Schedule the tweet
        const tweetId = scheduleTweet(tweetData, scheduleDate.toISOString());
        
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          scheduledTime: scheduleDate.toISOString(),
          timeSlot: timeSlots[timeSlotIndex],
          day: dayOffset + 1,
          tweetId: tweetId,
          imageCount: article.images.length,
          aiContent: aiContent.substring(0, 50) + '...'
        });
        
        console.log(`???? l?p l?ch bï¿½ï¿½i ${i + 1}: ${scheduleDate.toLocaleString('vi-VN')} (${timeSlots[timeSlotIndex]})`);
        
        // Small delay to avoid overwhelming
        if (i < selectedArticles.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
      } catch (error) {
        console.error(`??L?i x??ly bï¿½ï¿½i ${i + 1}:`, error);
        scheduleResults.push({
          articleIndex: i + 1,
          title: article.title.substring(0, 50) + '...',
          error: error.message
        });
      }
    }

    const successCount = scheduleResults.filter(r => !r.error).length;
    
    res.json({ 
      success: true, 
      message: `?? t????ng l?p l?ch ${successCount}/${selectedArticles.length} bï¿½ï¿½i thï¿½ï¿½nh c?ng!`,
      articlesProcessed: selectedArticles.length,
      scheduledTweets: successCount,
      scheduleDetails: scheduleResults
    });

  } catch (error) {
    console.error('??L?i auto schedule 20:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Removed Chinese tweet generation endpoint

// API: Post tweet (with multiple images or video)
app.post('/api/twitter/post', upload.array('images', 4), async (req, res) => {
  let uploadedFiles = [];
  
  try {
    const { text, imageUrls } = req.body;
    uploadedFiles = req.files || [];
    
    if (!text || text.trim().length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Content required' 
      });
    }

    if (text.length > 280) {
      return res.status(400).json({ 
        success: false, 
        error: 'Tweet too long' 
      });
    }

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' 
      });
    }

    const client = createTwitterClient(config);
    
    let mediaIds = [];
    const uploadDir = path.join(__dirname, 'uploads');
    if (!fsSync.existsSync(uploadDir)) {
      fsSync.mkdirSync(uploadDir, { recursive: true });
    }

    // Handle images only
    const imagesToUpload = [];
    
    // Add uploaded files
    uploadedFiles.forEach(file => {
      imagesToUpload.push({ type: 'file', path: file.path });
    });

    // Upload images directly from URLs (no file saving)
    if (imageUrls) {
      try {
        const urls = JSON.parse(imageUrls);
        console.log('?? Danh sï¿½ï¿½ch URL ?nh:', urls);

        // Upload all 4 images directly to Twitter
        for (const url of urls.slice(0, 4)) { // Take up to 4 images
          try {
            const mediaId = await downloadAndUploadImage(client, url, `(main-${mediaIds.length + 1})`);
            mediaIds.push(mediaId);
            console.log(`âœ… Successfully uploaded image ${mediaIds.length}/4 from URL: ${url}`);
          } catch (urlError) {
            console.error('âŒ Lá»—i xá»­ lÃ½ áº£nh tá»« URL:', url);
            console.error('âŒ Chi tiáº¿t lá»—i:', urlError.message);
            // Continue with other images if one fails
          }
        }
      } catch (error) {
        console.error('??L?i x??ly danh sï¿½ï¿½ch URL ?nh:', error);
        // Don't throw error, just continue without images
      }
    }

    // Upload local files to Twitter (if any)
    if (imagesToUpload.length > 0) {
      console.log(`?? T?ng c?ng ${imagesToUpload.length} file local c?n upload`);
      for (const img of imagesToUpload.slice(0, 4 - mediaIds.length)) { // Don't exceed 4 total
        try {
          console.log('?? ?ang upload file local:', path.basename(img.path));
          const mediaId = await client.v1.uploadMedia(img.path);
          mediaIds.push(mediaId);
          console.log('???? upload file local lï¿½ï¿½n Twitter, Media ID:', mediaId);
        } catch (error) {
          console.error('??L?i upload file local:', error);
          // Continue with other files if one fails
        }
      }
    }
    
    // Post tweet with media
    const tweetOptions = { text };
    if (mediaIds.length > 0) {
      tweetOptions.media = { media_ids: mediaIds };
    }
    
    console.log('?? ?ang ??ng tweet lï¿½ï¿½n Twitter...');
    const tweet = await client.v2.tweet(tweetOptions);
    console.log('???? ??ng tweet thï¿½ï¿½nh c?ng! Tweet ID:', tweet.data.id);
    
    // Keep uploaded files (don't delete as requested)
    console.log('ğŸ“ Giá»¯ láº¡i cÃ¡c file Ä‘Ã£ upload...');
    for (const file of uploadedFiles) {
      console.log('ğŸ“ Giá»¯ láº¡i file upload:', path.basename(file.path), 'táº¡i', file.path);
    }
    console.log('âœ… HoÃ n táº¥t! ÄÃ£ giá»¯ láº¡i táº¥t cáº£ file.');
    
    res.json({ 
      success: true, 
      tweetId: tweet.data.id,
      message: mediaIds.length > 0 
        ? `?? ??ng tweet kï¿½ï¿½m ${mediaIds.length} ?nh thï¿½ï¿½nh c?ng`
        : '?? ??ng tweet thï¿½ï¿½nh c?ng',
      imageCount: mediaIds.length
    });
  } catch (error) {
    console.error('??Twitter API Error:', error);
    
    // Keep uploaded files (don't delete as requested)
    console.log('ğŸ“ Giá»¯ láº¡i cÃ¡c file upload do lá»—i xáº£y ra...');
    for (const file of uploadedFiles) {
      console.log('ğŸ“ Giá»¯ láº¡i file upload:', path.basename(file.path), 'táº¡i', file.path);
    }
    
    res.status(500).json({ 
      success: false, 
      error: error.message || 'L?i khi ??ng tweet' 
    });
  }
});

// API: Auto post from DOCX
app.post('/api/twitter/auto-post', async (req, res) => {
  try {
    const data = await getContentFromDocx();
    const config = await loadConfig();
    
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ success: false, error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' });
    }

    const client = createTwitterClient(config);
    const tweet = await client.v2.tweet(data.content);
    
    res.json({ 
      success: true, 
      tweetId: tweet.data.id,
      message: `?? t????ng ??ng bï¿½ï¿½i t??${data.fileName}`
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint: fetch first article from external API and return title + up to 4 images
app.get('/external/first', async (req, res) => {
  try {
    // Allow passing api url via query ?url=..., otherwise use provided default
    const apiUrl = req.query.url || 'https://beiyong.slapibf.com/api.php/provide/art/?ac=detail&pg=1&t=72';
    const data = await fetchFirstArticleFromApi(apiUrl);
    res.json({ success: true, data });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint: fetch first article and post it to Twitter (requires keys configured)
app.post('/external/post-first', async (req, res) => {
  try {
    const apiUrl = req.body.url || 'https://beiyong.slapibf.com/api.php/provide/art/?ac=detail&pg=1&t=72';
    const article = await fetchFirstArticleFromApi(apiUrl);

    const config = await loadConfig();
    if (!hasTwitterKeys(config)) {
      return res.status(400).json({ success: false, error: 'Not configured hï¿½ï¿½nh khï¿½ï¿½a Twitter' });
    }

    const client = createTwitterClient(config);

    // Upload images directly to Twitter without saving to disk
    const mediaIds = [];

    for (const url of (article.imageUrls || []).slice(0, 4)) {
      try {
        console.log('???ang upload ?nh tr?c ti?p t??URL (external):', url);
        const response = await axios.get(url, { 
          responseType: 'arraybuffer', 
          timeout: 15000, 
          headers: { 'User-Agent': 'Mozilla/5.0' } 
        });

        // Upload directly to Twitter without saving to disk
        const mimeType = getMimeTypeFromResponse(response, url);
        const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(external)');
        mediaIds.push(mediaId);
      } catch (err) {
        console.warn('??Kh?ng th??upload ?nh t??URL:', url, err.message);
      }
    }

    // Post tweet
    const tweetOptions = { text: article.art_name };
    if (mediaIds.length) tweetOptions.media = { media_ids: mediaIds };

    const tweet = await client.v2.tweet(tweetOptions);

    res.json({ success: true, tweetId: tweet.data.id, imageCount: mediaIds.length });
  } catch (error) {
    console.error('Error posting external first article:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// --- Multi-article fetch and scheduling ---

// Fetch multiple articles from API (tries to find array of objects with art_name + art_content)
async function fetchArticlesFromApi(apiUrl, limit = 20) {
  const res = await axios.get(apiUrl, { timeout: 15000 });
  const body = res.data;

  const results = [];

  function extractFromObject(obj) {
    if (!obj || typeof obj !== 'object') return;
    if (obj.art_name && obj.art_content) {
      const $ = cheerio.load(obj.art_content || '');
      const imgs = [];
      $('img').each((i, el) => { const src = $(el).attr('src'); if (src) imgs.push(src); });
      results.push({ art_name: obj.art_name, art_content: obj.art_content, imageUrls: imgs.slice(0, 4) });
      return;
    }
    for (const k of Object.keys(obj)) {
      const v = obj[k];
      if (Array.isArray(v)) {
        for (const item of v) {
          if (results.length >= limit) return;
          extractFromObject(item);
        }
      } else if (typeof v === 'object') {
        if (results.length >= limit) return;
        extractFromObject(v);
      }
      if (results.length >= limit) return;
    }
  }

  extractFromObject(body);

  return results.slice(0, limit);
}

// Generate extra short text (caption/hashtags) using OpenRouter
async function generateExtraContent(article) {
  if (!OPENROUTER_KEY) throw new Error('OpenRouter API key not configured');

  const title = article.art_name || '';
  const content = (article.art_content || '').replace(/<[^>]+>/g, ' ');

  const prompt = `B?n lï¿½ï¿½ m?t tr??ly vi?t Content required ng?n cho Twitter b?ng ti?ng Vi?t. D?a vï¿½ï¿½o title?? "${title}" vï¿½ï¿½ Content required: "${content}", h?y t?o: (1) m?t caption ng?n 1-2 cau, (2) 3 hashtag phï¿½ï¿½ h?p. Tr??v????d?ng: caption newline hashtags (vï¿½ï¿½ d?? #tag1 #tag2 #tag3). Kh?ng thï¿½ï¿½m gi?i thï¿½ï¿½ch khï¿½ï¿½c.`;

  const payload = {
    model: OPENROUTER_MODEL,
    messages: [
      { role: 'system', content: 'B?n lï¿½ï¿½ m?t tr??ly vi?t Content required ng?n, sï¿½ï¿½c tï¿½ï¿½ch.' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.8,
    max_tokens: 200
  };

  const resp = await axios.post('https://api.openrouter.ai/v1/chat/completions', payload, {
    headers: {
      'Authorization': `Bearer ${OPENROUTER_KEY}`,
      'Content-Type': 'application/json'
    },
    timeout: 20000
  });

  // Response format: choices[0].message.content
  const text = resp.data && resp.data.choices && resp.data.choices[0] && (resp.data.choices[0].message ? resp.data.choices[0].message.content : resp.data.choices[0].text);
  return (text || '').trim();
}

// Generate full rewritten title and full content using OpenRouter
async function generateFullContent(article) {
  if (!OPENROUTER_KEY) throw new Error('OpenRouter API key not configured');

  const title = article.art_name || '';
  const content = (article.art_content || '').replace(/<[^>]+>/g, ' ');

  const prompt = `B?n lï¿½ï¿½ m?t tr??ly vi?t l?i bï¿½ï¿½i b?ng ti?ng Vi?t. D?a trï¿½ï¿½n title?? "${title}" vï¿½ï¿½ Content required hi?n cï¿½ï¿½: "${content}", h?y:
1) Vi?t l?i m?t title??m?i, b?t m?t vï¿½ï¿½ phï¿½ï¿½ h?p cho Twitter.
2) Vi?t l?i Content required bï¿½ï¿½i ??y ??? m?ch l?c, ?o?n v?n r? rï¿½ï¿½ng, dï¿½ï¿½ng ng?n ng??t??nhiï¿½ï¿½n, dï¿½ï¿½i kho?ng 3-6 ?o?n.
Tr??v??k?t qu????d?ng JSON ch??g?m hai tr??ng: {"new_title":"...","full_content":"..."} vï¿½ï¿½ kh?ng cï¿½ï¿½ gi?i thï¿½ï¿½ch khï¿½ï¿½c.`;

  const payload = {
    model: OPENROUTER_MODEL,
    messages: [
      { role: 'system', content: 'B?n lï¿½ï¿½ m?t tr??ly vi?t l?i bï¿½ï¿½i chuyï¿½ï¿½n nghi?p, sï¿½ï¿½ng t?o, b?ng ti?ng Vi?t.' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.8,
    max_tokens: 1200
  };

  const resp = await axios.post('https://api.openrouter.ai/v1/chat/completions', payload, {
    headers: {
      'Authorization': `Bearer ${OPENROUTER_KEY}`,
      'Content-Type': 'application/json'
    },
    timeout: 60000
  });

  const text = resp.data && resp.data.choices && resp.data.choices[0] && (resp.data.choices[0].message ? resp.data.choices[0].message.content : resp.data.choices[0].text);
  if (!text) throw new Error('OpenRouter returned empty response');

  // Try to parse JSON from model output; if model wraps with markdown or text, try to extract JSON substring
  let parsed = null;
  try {
    parsed = JSON.parse(text.trim());
  } catch (e) {
    // attempt to find first { ... } block
    const m = text.match(/\{[\s\S]*\}/);
    if (m) {
      try { parsed = JSON.parse(m[0]); } catch (e2) { /* fallthrough */ }
    }
  }

  if (!parsed) {
    // Fallback: return text as full_content and keep original title
    return { new_title: title, full_content: text.trim() };
  }

  return { new_title: parsed.new_title || title, full_content: parsed.full_content || '' };
}

// Post a single article object {art_name, imageUrls[]} to Twitter, return result
async function postArticleToTwitter(article, config, options = {}) {
  const client = createTwitterClient(config);

  const mediaIds = [];

  for (const url of (article.imageUrls || []).slice(0, 4)) {
    try {
      console.log('???ang upload ?nh tr?c ti?p t??URL (postArticleToTwitter):', url);
      const response = await axios.get(url, { 
        responseType: 'arraybuffer', 
        timeout: 15000, 
        headers: { 'User-Agent': 'Mozilla/5.0' } 
      });

      // Upload directly to Twitter without saving to disk
      const mimeType = getMimeTypeFromResponse(response, url);
      const mediaId = await uploadImageToTwitter(client, Buffer.from(response.data), mimeType, '(postArticleToTwitter)');
      mediaIds.push(mediaId);
      
      // small delay between uploads to be gentle
      await new Promise(r => setTimeout(r, 300));
    } catch (err) {
      console.warn('??Kh?ng th??upload ?nh t??URL:', url, err.message);
    }
  }

  // Optionally generate extra content via OpenRouter
  let extraText = '';
  if (options.generate && OPENROUTER_KEY) {
    try {
      extraText = await generateExtraContent(article);
    } catch (e) {
      console.warn('OpenRouter generation failed:', e.message);
      extraText = '';
    }
  }

  // Compose tweet text: title + extra (ensure <= 280 chars)
  let tweetText = article.art_name || '';
  if (extraText) tweetText += '\n\n' + extraText;
  if (tweetText.length > 280) {
    // truncate extraText first
    const allowedExtra = 280 - (article.art_name || '').length - 2;
    if (allowedExtra > 0) {
      tweetText = (article.art_name || '') + '\n\n' + extraText.slice(0, allowedExtra - 3) + '...';
    } else {
      tweetText = tweetText.slice(0, 277) + '...';
    }
  }

  const tweetOptions = { text: tweetText };
  if (mediaIds.length) tweetOptions.media = { media_ids: mediaIds };

  const tweet = await client.v2.tweet(tweetOptions);

  return { tweetId: tweet.data.id, imageCount: mediaIds.length };
}



// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ 
    success: false, 
    error: process.env.NODE_ENV === 'production' ? 'Internal Server Error' : err.message 
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>404 - Not Found</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        h1 { color: #1da1f2; }
      </style>
    </head>
    <body>
      <h1>404 - Page Not Found</h1>
      <p>The page you're looking for doesn't exist.</p>
      <a href="/">Go to Home</a> | <a href="/twitter">Twitter Manager</a>
    </body>
    </html>
  `);
});

const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`ğŸš€ Server Ä‘ang cháº¡y táº¡i port ${PORT}`);
  console.log(`ğŸ“± Dashboard: http://localhost:${PORT}/dashboard`);
  console.log(`ğŸ“„ DOCX: http://localhost:${PORT}/docx`);
  console.log(`ğŸ“Š Data files: ./data/`);
  console.log(`ğŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);
  
  // Initialize scheduler on startup
  console.log('ğŸ“… Khá»Ÿi táº¡o scheduler manager...');
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Process terminated');
  });
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  server.close(() => {
    console.log('Process terminated');
  });
});
